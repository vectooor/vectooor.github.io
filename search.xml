<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux中select、epoll的学习和理解</title>
    <url>/2020/01/07/linux-epoll/</url>
    <content><![CDATA[<p>近期在学习Java NIO，而后要进一步了解Netty，因为很多项目都用到Netty，所以，通过学习Java NIO的底层实现机制，可以更好的掌握。在Linux环境下，Java NIO实现底层是通过epoll。这里对相关学习资料进行整理。内容大部分来自网络。主要参考<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">链接</a>。</p>
<a id="more"></a>

<h3 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1 预备知识"></a>1 预备知识</h3><p>以下的每个知识点深入，都要涉及到更多更深的知识，这不在本文的范畴之内。这里只需要对这些概念进行一个宏观上的大致了解，便于理解接下来的文章主题即可。</p>
<ul>
<li>用户空间和内核空间</li>
<li>进程切换</li>
<li>进程阻塞</li>
<li>文件描述符</li>
<li>缓存I/O</li>
</ul>
<h4 id="1-1-用户空间和内核空间"><a href="#1-1-用户空间和内核空间" class="headerlink" title="1.1 用户空间和内核空间"></a>1.1 用户空间和内核空间</h4><p>简单来说，操作系统也是程序，其核心我们称之为内核（kernel），相应的用户自己编写的程序我们称之为用户程序。为了保证用户程序不能直接操作内核，保证内核的安全，操作系统将内存分为两个部分，一部分为内核空间，一部分为用户空间。针对Linux操作系统而言，将最高的1G字节（从虚拟地址<code>0xC0000000</code>到<code>0xFFFFFFFF</code>），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址<code>0x00000000</code>到<code>0xBFFFFFFF</code>），供各个进程使用，称为用户空间（假设内存为4G）。现在的操作系统都是采用<a href="https://www.zhihu.com/question/21088377" target="_blank" rel="noopener">虚拟存储器</a>。关于虚拟存储器，可以自行寻找资料进一步了解。</p>
<p><img src="/images/linux-architecture.png" alt=""></p>
<p>这里顺便说一下用户态和和内核态。</p>
<ul>
<li>内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。</li>
<li>用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。</li>
</ul>
<p>用户程序由用户态进入到内核态最直接的方式就是系统调用（<code>system call</code>）。</p>
<blockquote>
<p>这里个人有个疑问：用户态切到内核态非常耗资源（因为需要保存当前用户态的状态，进入到内核态执行，执行完毕后，需要将之前的用户态恢复），而CPU资源是通过内核进行管控的，用户态的程序需要使用CPU执行权，那岂不是无时无刻不在进行用户态到内核态的切换？</p>
<p>经多方资料查阅，得到如下答案：Linux下，CPU等级分为四级，Ring0~Ring3，内核态执行时，CPU权限级别为Ring0，可以访问所有资源；用户态执行时，CPU权限级别为Ring3。也就是说，CPU也存在内核态（Ring0）和用户态（Ring3）。Ring1和Ring2目前在Linux中暂未使用。</p>
</blockquote>
<h4 id="1-2-进程切换"><a href="#1-2-进程切换" class="headerlink" title="1.2 进程切换"></a>1.2 进程切换</h4><p>根据百度百科的解释：</p>
<blockquote>
<p>操作系统为了控制进程的执行，必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行，这种行为被称为进程切换，任务切换或上下文切换。</p>
</blockquote>
<p>进程的切换分为以下步骤：</p>
<ol>
<li>决定是否作上下文切换以及是否允许作上下文切换。</li>
<li>保存当前执行进程的上下文。</li>
<li>使用进程调度算法，选择一处于就绪状态的进程。</li>
<li>恢复或装配所选进程的上下文，将CPU控制权交到所选进程手中。</li>
</ol>
<p>总的一句话就是：<strong>进程切换很耗资源</strong>。</p>
<h4 id="1-3-进程阻塞"><a href="#1-3-进程阻塞" class="headerlink" title="1.3 进程阻塞"></a>1.3 进程阻塞</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语（Block），使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<strong>当进程进入阻塞状态，是不占用CPU资源的</strong>。</p>
<h4 id="1-4-文件描述符"><a href="#1-4-文件描述符" class="headerlink" title="1.4 文件描述符"></a>1.4 文件描述符</h4><p>在国内，也将文件描述符翻译为<strong>句柄</strong>。文件描述符维基百科的解释：</p>
<blockquote>
<p><strong>文件描述符</strong>（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
</blockquote>
<p>Linux的设计思想就是一切皆文件。我们经常打交道的文件好理解，比如一个日志文件，一个<code>.c</code>的源码文件等。对于建盘、屏幕、鼠标等外设，Linux中也将其视为文件，这有点神奇。<strong>Linux将一个Socket也视为一个文件</strong>。不要问为什么，这是规定。每个进程都有一个文件描述符表，同一进程不同文件描述符可能指向同一文件。</p>
<h4 id="1-5-缓存I-O"><a href="#1-5-缓存I-O" class="headerlink" title="1.5 缓存I/O"></a>1.5 缓存I/O</h4><p>缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存（page cache）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<p>缓存I/O的缺点：<em>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU以及内存开销是非常大的。</em></p>
<h3 id="2-IO模式"><a href="#2-IO模式" class="headerlink" title="2 IO模式"></a>2 IO模式</h3><p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p>正式因为这两个阶段，Linux系统产生了下面五种网络模式的方案。</p>
<ul>
<li>阻塞 I/O（blocking IO）</li>
<li>非阻塞 I/O（nonblocking IO）</li>
<li>I/O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I/O（ signal driven IO）</li>
<li>异步 I/O（asynchronous IO）</li>
</ul>
<p>注：由于signal driven IO在实际中并不常用，这里不讨论。</p>
<h4 id="2-1-阻塞I-O（blocking-IO）"><a href="#2-1-阻塞I-O（blocking-IO）" class="headerlink" title="2.1 阻塞I/O（blocking IO）"></a>2.1 阻塞I/O（blocking IO）</h4><p>在Linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p>
<p><img src="/images/blocking-io.png" alt=""></p>
<p>当用户进程调用了<code>recvfrom</code>这个系统调用，内核就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候内核就要等待完整的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当内核数据准备完毕，它就会将数据从内核中拷贝到用户内存，然后内核返回结果，用户进程才解除阻塞状态，重新运行起来。</p>
<p>所以，阻塞IO的特点就是两个阶段（等待、读取）都阻塞了。</p>
<blockquote>
<p>这里的读取操作是内存级别的操作，速度可达1Gb/s，可以理解为不耗时，也就是不阻塞。</p>
</blockquote>
<h4 id="2-2-非阻塞-I-O（nonblocking-IO）"><a href="#2-2-非阻塞-I-O（nonblocking-IO）" class="headerlink" title="2.2 非阻塞 I/O（nonblocking IO）"></a>2.2 非阻塞 I/O（nonblocking IO）</h4><p>Linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p>
<p><img src="/images/nonblocking-io.png" alt=""></p>
<p>当用户进程发出read操作时，如果内核中的数据还没有准备好，那么它并不会阻塞用户进程，而是立刻返回一个错误。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个错误时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户进程的系统调用，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p>所以，nonblocking IO的特点是用户进程需要不断的主动询问内核数据是否已准备完毕。</p>
<h4 id="2-3-多路复用I-O（-IO-multiplexing）"><a href="#2-3-多路复用I-O（-IO-multiplexing）" class="headerlink" title="2.3  多路复用I/O（ IO multiplexing）"></a>2.3  多路复用I/O（ IO multiplexing）</h4><p>IO multiplexing就是我们说的<code>select</code>，<code>poll</code>，<code>epoll</code>，有些地方也称这种IO方式为事件驱动IO（event driven IO）。<code>select/epoll</code>的好处就在于单个进程就可以同时处理多个网络连接的IO。它的基本原理就是<code>select</code>，<code>poll</code>，<code>epoll</code>这几函数会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p><img src="/images/multiplexing-io.png" alt=""></p>
<p><strong>当用户调用了<code>select</code>，那么整个进程就会阻塞。</strong>内核会”监视“所有<code>select</code>负责的socket，当任何一个socket中的数据准备好了，<code>select</code>就会返回。这个时候用户进程再调用read操作，将数据从内核拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，<code>select</code>函数就可以返回。</p>
<p>该模式的图，从表面上看，还不如阻塞IO的模型，因为阻塞IO只进行了一次系统调用，而这里进行了两次系统调用。但<code>select</code>的优势在于它能管理多个连接（connection）。所以，对于连接数较少的web服务器，<code>select、poll</code>的性能可能还不如阻塞IO的性能。</p>
<p>在多路复用I/O中，对于每个socket，一般都设置为非阻塞的。上图中，用户进程是阻塞的，但是是被<code>select</code>函数阻塞，而不是被socket阻塞。</p>
<h4 id="2-4-异步I-O（asynchronous-IO）"><a href="#2-4-异步I-O（asynchronous-IO）" class="headerlink" title="2.4 异步I/O（asynchronous IO）"></a>2.4 异步I/O（asynchronous IO）</h4><p>Linux下的asynchronous IO其实用得很少。先看一下它的流程：</p>
<p><img src="/images/asynchronous-io.png" alt=""></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何阻塞。然后，内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，内核会给用户进程发送一个信号（signal），告诉它read操作完成了。</p>
<h4 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h4><p>各个IO模型的比较如图所示：</p>
<p><img src="/images/linux-io-model-summary.png" alt=""></p>
<p>阻塞和非阻塞的区别：调用blocking IO会一直阻塞对应的进程直到操作完成，而non-blocking IO在内核还准备数据的情况下会立刻返回。</p>
<p>同步和异步的区别，根据POSIX的解释：</p>
<blockquote>
<p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</p>
<p>An asynchronous I/O operation does not cause the requesting process to be blocked;</p>
</blockquote>
<p>显然，上述的四种IO，除了异步IO，其他三个都属于同步IO。</p>
<h3 id="3-多路复用I-O之select、epoll详解"><a href="#3-多路复用I-O之select、epoll详解" class="headerlink" title="3 多路复用I/O之select、epoll详解"></a>3 多路复用I/O之select、epoll详解</h3><p>这里不对<code>select</code>和<code>epoll</code>的底层实现做过多描述，只是在宏观上理解两个函数的异同。</p>
<h4 id="3-1-select"><a href="#3-1-select" class="headerlink" title="3.1 select"></a>3.1 select</h4><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Check the first NFDS descriptors each in READFDS (if not NULL) for read</span></span><br><span class="line"><span class="comment">   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS</span></span><br><span class="line"><span class="comment">   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out</span></span><br><span class="line"><span class="comment">   after waiting the interval specified therein.  Returns the number of ready</span></span><br><span class="line"><span class="comment">   descriptors, or -1 for errors.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> __nfds, fd_set *__restrict __readfds,</span></span></span><br><span class="line"><span class="function"><span class="params">                   fd_set *__restrict __writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                   fd_set *__restrict __exceptfds,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct timeval *__restrict __timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后<code>select</code>函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
<p><code>select</code>的几大缺点：</p>
<ol>
<li><p>每次调用<code>select</code>，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；</p>
</li>
<li><p>同时每次调用<code>select</code>都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大；</p>
</li>
<li><p><code>select</code>支持的文件描述符数量太小了，默认是1024。</p>
</li>
</ol>
<h4 id="3-2-epoll"><a href="#3-2-epoll" class="headerlink" title="3.2 epoll"></a>3.2 epoll</h4><p>函数原型，可以在文件（<code>/usr/include/sys/epoll.h</code>）中找到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Creates an epoll instance.  Returns an fd for the new instance.</span></span><br><span class="line"><span class="comment">   The "size" parameter is a hint specifying the number of file</span></span><br><span class="line"><span class="comment">   descriptors to be associated with the new instance.  The fd</span></span><br><span class="line"><span class="comment">   returned by epoll_create() should be closed with close().  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">epoll_create</span> <span class="params">(<span class="keyword">int</span> __size)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Manipulate an epoll instance "epfd". Returns 0 in case of success,</span></span><br><span class="line"><span class="comment">   -1 in case of error ( the "errno" variable will contain the</span></span><br><span class="line"><span class="comment">   specific error code ) The "op" parameter is one of the EPOLL_CTL_*</span></span><br><span class="line"><span class="comment">   constants defined above. The "fd" parameter is the target of the</span></span><br><span class="line"><span class="comment">   operation. The "event" parameter describes which events the caller</span></span><br><span class="line"><span class="comment">   is interested in and any associated user data.  */</span></span><br><span class="line"><span class="comment">// 这里的__fd参数就是每次Socket连接建立以后的文件描述符</span></span><br><span class="line"><span class="comment">// 每次Socket建立以后得到一个__fd，然后在这里对__fd新注册读事件</span></span><br><span class="line"><span class="comment">// 读完以后对该fd的监测事件进行修改，修改为写事件</span></span><br><span class="line"><span class="comment">// 也就是说，__epfd句柄下，会有多个__fd</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">epoll_ctl</span> <span class="params">(<span class="keyword">int</span> __epfd, <span class="keyword">int</span> __op, <span class="keyword">int</span> __fd,</span></span></span><br><span class="line"><span class="function"><span class="params">                      struct epoll_event *__event)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for events on an epoll instance "epfd". Returns the number of</span></span><br><span class="line"><span class="comment">   triggered events returned in "events" buffer. Or -1 in case of</span></span><br><span class="line"><span class="comment">   error with the "errno" variable set to the specific error code. The</span></span><br><span class="line"><span class="comment">   "events" parameter is a buffer that will contain triggered</span></span><br><span class="line"><span class="comment">   events. The "maxevents" is the maximum number of events to be</span></span><br><span class="line"><span class="comment">   returned ( usually size of "events" ). The "timeout" parameter</span></span><br><span class="line"><span class="comment">   specifies the maximum wait time in milliseconds (-1 == infinite).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">epoll_wait</span> <span class="params">(<span class="keyword">int</span> __epfd, struct epoll_event *__events,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> __maxevents, <span class="keyword">int</span> __timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>epoll</code>是对<code>select</code>和<code>poll</code>的改进。在此之前，<code>select</code>和<code>poll</code>都只提供了一个函数——<code>select</code>或者<code>poll</code>函数。而<code>epoll</code>提供了三个函数，<code>epoll_create</code>、<code>epoll_ctl</code>和<code>epoll_wait</code>，<code>epoll_create</code>是创建一个<code>epoll</code>句柄；<code>epoll_ctl</code>是注册要监听的事件类型；<code>epoll_wait</code>则是等待事件的产生。</p>
<p>相较于<code>select</code>，<code>epoll</code>具备以下优点：</p>
<ol>
<li><p>没有最大并发连接的限制，能打开的fd的上限远大于1024（1G的内存上能监听约10万个端口）。</p>
</li>
<li><p>效率提升，不是轮询的方式，不会随着fd数目的增加效率下降。只有活跃可用的fd才会调用回调函数；即<code>epoll</code>最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，<code>epoll</code>的效率就会远远高于<code>select</code>和<code>poll</code>。</p>
</li>
<li><p>内存拷贝，利用mmap文件映射内存加速与内核空间的消息传递；即<code>epoll</code>使用mmap减少复制开销。</p>
</li>
</ol>
<h4 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h4><table>
<thead>
<tr>
<th>系统调用</th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody><tr>
<td>事件集合</td>
<td>用户通过3个参数分别传入感兴趣的可读，可写及异常等事件，内核通过对这些参数的在线修改来反馈其中的就绪事件这使得用户每次调用select都要重置这3个参数。</td>
<td>统一处理所有事件类型，因此只需要一个事件集参数。用户通过pollfd.events传入感兴趣的事件，内核通过修改pollfd.revents反馈其中就绪的事件</td>
<td>内核通过一个事件表直接管理用户感兴趣的所有事件。因此每次调用epoll_wait时，无需反复传入用户感兴趣的事件。epoll_wait系统调用的参数events仅用来反馈就绪的事件</td>
</tr>
<tr>
<td>应用程序索引就绪文件， 描述符的时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>最大支持文件描述符数</td>
<td>一般有最大值限制(默认1024)</td>
<td>65535</td>
<td>65535</td>
</tr>
<tr>
<td>工作模式</td>
<td>LT</td>
<td>LT</td>
<td>支持ET高效模式</td>
</tr>
<tr>
<td>内核实现和工作效率</td>
<td>采用轮询方式检测就绪事件，时间复杂度：O(n)</td>
<td>采用轮询方式检测就绪事件，时间复杂度：O(n)</td>
<td>采用回调方式检测就绪事件，时间复杂度：O(1)</td>
</tr>
</tbody></table>
<p>以上。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Socket</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下的awk、sed命令及正则表达式</title>
    <url>/2020/01/03/linux-awk-sed-and-regExp/</url>
    <content><![CDATA[<p>Linux提供了awk和sed两个强大的命令行文本处理工具，在对大型日志文件分析时特别有用。对文本的处理结合正则表达式可以高效的获取自己想要的日志信息。本文只是对awk、sed和正则表达式在笔者使用过程中遇到的一些比较常用的功能进行记录，更详细的使用方法可以去相应的官方网站查看。</p>
<a id="more"></a>

<h3 id="1-awk简单介绍"><a href="#1-awk简单介绍" class="headerlink" title="1 awk简单介绍"></a>1 awk简单介绍</h3><p>根据维基百科的<a href="https://zh.wikipedia.org/wiki/AWK" target="_blank" rel="noopener">介绍</a>：</p>
<blockquote>
<p>AWK是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一。这种编程及数据操作语言的最大功能取决于一个人所拥有的知识。AWK提供了极其强大的功能：可以进行正则表达式的匹配，样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。</p>
</blockquote>
<p>几乎所有的Linux都自带<code>awk</code>命令。它依次处理文件的每一行，并读取里面的每一个字段。对于日志文件那样的每行格式相同的文本文件，<code>awk</code>可能是最方便的工具。</p>
<h4 id="1-1-基本用法"><a href="#1-1-基本用法" class="headerlink" title="1.1 基本用法"></a>1.1 基本用法</h4><p>基本语法命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 格式</span><br><span class="line">$ awk actions fileName</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line">$ awk &apos;&#123;print $0&#125;&apos; test.log</span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>test.log</code>就是要处理的文本文件。<code>actions</code>即动作，写在一对单引号内，引号内的命令一般需要一对大括号括起来。<code>print</code>是打印命令。</p>
<p>根据以上的基础语法，我们进行一次实践。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里顺便学习<span class="built_in">echo</span>命令如何输出单引号，目前了解到的方式是通过双引号把单引号引起来，然后将单引号两侧的字符串通过单引号引起来，放在一起即可。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'I'</span><span class="string">"'"</span><span class="string">'m learning awk'</span> | awk <span class="string">'&#123;print $0&#125;'</span></span></span><br><span class="line">I'm learning awk</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'I'</span><span class="string">"'"</span><span class="string">'m learning awk'</span> | awk <span class="string">'&#123;print $1&#125;'</span></span></span><br><span class="line">I'm</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'I'</span><span class="string">"'"</span><span class="string">'m learning awk'</span> | awk <span class="string">'&#123;print $2&#125;'</span></span></span><br><span class="line">learning</span><br></pre></td></tr></table></figure>

<p>以上，我们可以看到，<code>$0</code>代表的是整行，<code>$1</code>默认为第一列，<code>$2</code>、<code>$3</code>以此类推。默认的分隔符是空格或制表符，即<code>\t</code>的转义字符。</p>
<p>为便于加深理解，我们以<code>/etc/passwd</code>文件（该文件是通过冒号分开的有规律的文件）为例，进行如下操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd | awk -F<span class="string">':'</span> <span class="string">'&#123;print $1&#125;'</span></span></span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br></pre></td></tr></table></figure>

<p>我们通过<code>-F</code>指定行的分隔符，然后输出每行的第一列。</p>
<h4 id="1-2-内置变量"><a href="#1-2-内置变量" class="headerlink" title="1.2 内置变量"></a>1.2 内置变量</h4><p>内置变量我们可以通过<code>man awk</code>命令，在结果中搜索<code>Built-in Variables</code>可以查询到所有的内置变量，这里对一些常用的做简单学习。</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>man手册解释</th>
<th>个人理解</th>
</tr>
</thead>
<tbody><tr>
<td>NF</td>
<td>The number of fields in the current input record.</td>
<td>当前行通过分隔符切割后一共有多少个字段。$NF就代表最后一个字段，相应的$(NF-1)就是倒数第二个字段。</td>
</tr>
<tr>
<td>NR</td>
<td>The total number of input records seen so far.</td>
<td>表示当前处理的是第几行。</td>
</tr>
<tr>
<td>FILENAME</td>
<td>The name of the current input file.  If no files are specified on the command line, the value of FILENAME is “-”.  However, FILENAME is undefined inside the BEGIN block (unless set by getline).</td>
<td>当前处理的文件的文件名。</td>
</tr>
<tr>
<td>FS</td>
<td>The input field separator, a space by default.</td>
<td>字段分隔符，默认是空格和制表符。</td>
</tr>
<tr>
<td>RS</td>
<td>The input record separator, by default a newline.</td>
<td>行的分隔符，默认是换行符。</td>
</tr>
</tbody></table>
<p>根据以上的内置变量，对其中的部分进行实践。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出第一列和倒数第二列，中间用字符-隔开，双引号中的字符原样输出，如果是逗号，默认为空格</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd | awk -F<span class="string">':'</span> <span class="string">'&#123;print $1"-"$(NF-1)&#125;'</span></span></span><br><span class="line">root-/root</span><br><span class="line">bin-/bin</span><br><span class="line">daemon-/sbin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同上，输出行号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd | awk -F<span class="string">':'</span> <span class="string">'&#123;print NR ")", $1, $(NF-1)&#125;'</span></span></span><br><span class="line">1) root /root</span><br><span class="line">2) bin /bin</span><br><span class="line">3) daemon /sbin</span><br></pre></td></tr></table></figure>

<h4 id="1-3-常用操作"><a href="#1-3-常用操作" class="headerlink" title="1.3 常用操作"></a>1.3 常用操作</h4><p>准备文件awk.txt，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 12</span><br><span class="line">2 32</span><br><span class="line">2 32</span><br><span class="line">5 12</span><br><span class="line">5 12</span><br><span class="line">6 165</span><br><span class="line">6 165</span><br></pre></td></tr></table></figure>

<p>我们分别对其进行求和和去重操作。</p>
<h5 id="1-3-1-求和"><a href="#1-3-1-求和" class="headerlink" title="1.3.1 求和"></a>1.3.1 求和</h5><p>我们对第二列的值进行求和操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN &#123;sum = 0&#125; &#123;sum += $2&#125; END &#123;print sum&#125;'</span> awk.txt </span></span><br><span class="line">430</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同样的，可以进行求平均值操作，除以总行数即可</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN &#123;sum = 0&#125; &#123;sum += $2&#125; END &#123;print sum/NR&#125;'</span> awk.txt</span></span><br><span class="line">61.4286</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 格式化输出，同C语言的格式化输出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN &#123;sum = 0&#125; &#123;sum += $2&#125; END &#123;printf("%.2f\n"), sum/NR&#125;'</span> awk.txt</span></span><br><span class="line">61.43</span><br></pre></td></tr></table></figure>

<h5 id="1-3-2-去重"><a href="#1-3-2-去重" class="headerlink" title="1.3.2 去重"></a>1.3.2 去重</h5><p>去重有两种方案可以实现。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先使用sort进行排序，然后进行uniq操作</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sort awk.txt | uniq</span></span><br><span class="line">1 12</span><br><span class="line">2 32</span><br><span class="line">5 12</span><br><span class="line">6 165</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用awk</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'!a[$0]++'</span> awk.txt</span></span><br><span class="line">1 12</span><br><span class="line">2 32</span><br><span class="line">5 12</span><br><span class="line">6 165</span><br></pre></td></tr></table></figure>

<p>关于<code>!a[$0]++</code>的个人理解：</p>
<ul>
<li><code>awk</code>数组的下标可以为字符串（经证实，可以。如果不可以，<code>a[$0]</code>也可以理解为下标=<code>hash($0)</code>）和数字。</li>
<li>如果action为空，默认<code>action={print $0}</code>，上面的去重命令行等价于<code>awk &#39;!a[$0]++ {print $0}&#39; awk.txt</code>。</li>
<li><code>++</code>操作是先使用值，然后自增。</li>
</ul>
<p>由以上三点，可以得出以下执行逻辑：</p>
<blockquote>
<p>读取<code>a[$0]</code>的值，默认为0，进行非操作<code>!a[$0]</code>得到值为1，所以输出<code>$0</code>然后值自增为1，下一次执行的时候，如果<code>a[$0] != 0</code>，进行非操作，得到<code>0</code>，则该行不输出。</p>
</blockquote>
<h5 id="1-3-2-条件筛选"><a href="#1-3-2-条件筛选" class="headerlink" title="1.3.2 条件筛选"></a>1.3.2 条件筛选</h5><p>如果我们切割出来的列，包含了一些杂质，比如，本来该列均为数字，结果文件内容该位置出现的字母，那么，我们可以进一步进行条件筛选。以如下文本为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 12</span><br><span class="line">2 32</span><br><span class="line">2 32</span><br><span class="line">5 12</span><br><span class="line">5 12</span><br><span class="line">6 165</span><br><span class="line">6 165</span><br><span class="line">h hello</span><br></pre></td></tr></table></figure>

<p>我们的需求是筛选出第二列的所有数字，实现方式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'&#123;tmp = $2&#125; &#123;if (tmp ~ /[0-9]+/) &#123;print $2&#125;&#125;'</span> awk.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者如下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'/[0-9]+/ &#123;print&#125;'</span> awk.txt </span></span><br><span class="line">1 12</span><br><span class="line">2 32</span><br><span class="line">2 32</span><br><span class="line">5 12</span><br><span class="line">5 12</span><br><span class="line">6 165</span><br><span class="line">6 165</span><br></pre></td></tr></table></figure>

<p><code>~</code>是<code>awk</code>中的正则表达式的匹配，相应的还有<code>!~</code>操作符。关于正则表达式，后面会花时间进行初步学习。</p>
<h3 id="2-sed实践"><a href="#2-sed实践" class="headerlink" title="2 sed实践"></a>2 sed实践</h3><p>对<code>sed</code>不着过多笔墨，这里只对实际场景中用到的进行简单记录。更深层次的学习后续用到的时候在这里继续补充。目前<code>sed</code>在实战中的使用场景是，在<code>shell</code>启动脚本中，读取配置文件的参数，然后通过命令启动应用。有如下配置文件<code>key=value</code>格式，我们需要通过key读取到value。</p>
<p>配置文件sed.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.name=api-service</span><br><span class="line">server.port=8080</span><br><span class="line">server.path=/test</span><br></pre></td></tr></table></figure>

<p>我们需要分别读到服务名称、端口等信息，具体操作如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 读取服务名称</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'/server.name/!d;s/.*=//'</span> sed.txt | tr -d <span class="string">'\r'</span></span></span><br><span class="line">api-service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取启动端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'/server.port/!d;s/.*=//'</span> sed.txt | tr -d <span class="string">'\r'</span></span></span><br><span class="line">8080</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 依次类推</span></span><br></pre></td></tr></table></figure>

<p>对如上命令的理解和解释，在命令中以分号为界，分为两个部分：</p>
<ul>
<li><p>第一部分：<code>/server.name/!d</code></p>
<p><code>/server.name/</code>是一个正则表达式，表示包含字符串<code>server.name</code>的行，<code>d</code>是<code>sed</code>的一个删除命令操作，<code>!d</code>就是删除的反向操作，即删除所有不包含<code>server.name</code>字符串的行。执行<code>sed &#39;/server.name/!d&#39; sed.txt</code>可以得到<code>server.name=api-service</code>。</p>
</li>
<li><p>第二部分：<code>s/.*=//</code></p>
<p><code>s</code>在<code>sed</code>命令中的的含义为替换，后接的<code>/.*=/</code>是一个正则表达式，匹配的字符串为任何以<code>=</code>结尾的字符串，显然，这里匹配到的是<code>server.name=</code>。后面再接一个<code>/</code>，两个<code>/</code>之间的字符串为空，即将匹配到的字符串置为空，那么得到的结果就是<code>api-service</code>。</p>
</li>
</ul>
<p><code>tr</code>命令不在该文讨论范畴，可以自行查阅相关资料。这里的<code>tr -d &#39;\r&#39;</code>意思是删除末尾的换行符。</p>
<h3 id="3-正则表达式"><a href="#3-正则表达式" class="headerlink" title="3 正则表达式"></a>3 正则表达式</h3><p>该文已经较长，接下来单独开一篇学习正则表达式。</p>
<p>以上。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中Integer类型转String的注意事项</title>
    <url>/2019/12/02/java-integer-to-string/</url>
    <content><![CDATA[<p>在Java中，诸多场景都需要将Integer转为String的场景。之前图方便省事，直接 <code>+&quot;&quot;</code> 进行转化。今天特地对Integer转String进行适度的研究。（本文主要测试本地图片的引用方式）</p>
<a id="more"></a>

<h3 id="””操作"><a href="#””操作" class="headerlink" title="+””操作"></a>+””操作</h3><p>通过 <code>+&quot;&quot;</code> 进行实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer x = <span class="number">1</span>;</span><br><span class="line">        String s = x + <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，生成 <code>JVM.class</code> 文件，通过命令 <code>javap -verbose JVM.class</code> 查看，可以看到如下结果：</p>
<p><img src="/images/integer-to-string-pic1.png" alt=""></p>
<p>由此可以发现，通过 <code>+</code> 操作符连接一个空字符串的操作的时候，虚拟机实际的操作是新建了一个 <code>StringBuilder</code> 对象执行 <code>append</code> 操作去链接字符串。</p>
<h3 id="Integer-toString"><a href="#Integer-toString" class="headerlink" title="Integer.toString()"></a>Integer.toString()</h3><p>JDK的的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a &#123;<span class="doctag">@code</span> String&#125; object representing the</span></span><br><span class="line"><span class="comment"> * specified integer. The argument is converted to signed decimal</span></span><br><span class="line"><span class="comment"> * representation and returned as a string, exactly as if the</span></span><br><span class="line"><span class="comment"> * argument and radix 10 were given as arguments to the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #toString(int, int)&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   i   an integer to be converted.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a string representation of the argument in base&amp;nbsp;10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == Integer.MIN_VALUE)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-2147483648"</span>;</span><br><span class="line">    <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);</span><br><span class="line">    <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    getChars(i, size, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，针对Integer类型，专门实现了转String的方法。</p>
<h3 id="String-valueOf-int-i"><a href="#String-valueOf-int-i" class="headerlink" title="String.valueOf(int i)"></a>String.valueOf(int i)</h3><p>JDK的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the string representation of the &#123;<span class="doctag">@code</span> int&#125; argument.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The representation is exactly the one returned by the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Integer.toString&#125; method of one argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   i   an &#123;<span class="doctag">@code</span> int&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a string representation of the &#123;<span class="doctag">@code</span> int&#125; argument.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Integer#toString(int, int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String.valueOf</code> 还是调用了 <code>Integer.toString()</code> 。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>鉴于此，今后 <code>+&quot;&quot;</code> 的方案不建议使用。建议使用 <code>Integer.toString()</code> 或者 <code>String.valueOf()</code>。以上同样适用于Long、Double等类型的转换。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat返回头无OK字符的解决方案</title>
    <url>/2019/12/02/tomcat-response-without-OK-character/</url>
    <content><![CDATA[<p>公司业务架构升级，原来由PHP对外提供HTTP服务改为由SpringBoot（版本为2.1.3）提供，该版本默认的HTTP容器为Tomcat9，导致前端的返回头与原PHP返回的头不一致，从而引发前端一些老的接入终端出现问题。前端接入终端较多，切老旧设备的程序修改麻烦，所以必然需要后端来兼容前端。</p>
<a id="more"></a>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>PHP的返回头如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">date: Sat, 30 Nov 2019 13:53:42 GMT</span><br><span class="line">content-type: text/html;charset=UTF-8</span><br><span class="line">content-encoding: gzip</span><br></pre></td></tr></table></figure>
<p>改为Tomcat9以后，返回头如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200</span><br><span class="line">date: Sat, 30 Nov 2019 13:55:42 GMT</span><br><span class="line">content-type: text/html;charset=UTF-8</span><br><span class="line">content-encoding: gzip</span><br></pre></td></tr></table></figure>
<p>对比之下，发现Tomcat的返回少了“OK”两个字符。如果前端接入是较为高级一点的语言这不会有什么问题。但是对于一些比较古老的设备，基本上都是由C语言使用原生方式请求，接受到返回字符串后根据[HTTP/1.1 200 OK]去判断成功，否则报失败。这就相当坑爹了。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>经各方资料查阅，网络上这种文章都说通过配置tomcat的Connector参数<code>sendReasonPhrase=true</code>可以解决该问题。在tomcat的官方文档<code>https://tomcat.apache.org/tomcat-8.5-doc/config/http.html</code>找到关于<code>sendReasonPhrase</code>的如下描述：</p>
<blockquote>
<p>Set this attribute to true if you wish to have a reason phrase in the response. The default value is false.<br>Note: This option is deprecated and will be removed in Tomcat 9. The reason phrase will not be sent.</p>
</blockquote>
<p>由此，在Tomcat9中，该功能已经彻底无法实现了。所以只能通过降级到Tomcat8解决该问题。本人实测，降级到Tomcat8以后并设置<code>sendReasonPhrase=true</code>后该问题解决。Tomcat9尝试过添加该参数，无效。</p>
<p>需要注意的是，Tomcat有两种运行方式，一种是启动Tomcat，然后war包往webapps目录下扔即可。这种方式启动的直接在<code>$TOMCAT_HOME/conf/server.xml</code>中直接修改配置即可。<br>另一种是嵌入式的，比如在SpringBoot中是通过嵌入式方式启动的。对于这一种方式，要配置Tomcat的参数，需要实现接口<code>WebServerFactoryCustomizer</code>重写<code>customize</code>方法，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class PortalTomcatWebServerCustomizer implements WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void customize(TomcatServletWebServerFactory factory) &#123;</span><br><span class="line">        factory.addConnectorCustomizers(connector -&gt; connector.setAttribute(&quot;sendReasonPhrase&quot;, &quot;true&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>基于RabbitMQ的延时任务解决方案</title>
    <url>/2019/11/26/implement-delayed-task-by-rabbitmq/</url>
    <content><![CDATA[<p>公司的一个项目，有诸多场景需要用到延时任务，例如：</p>
<ul>
<li>创建的优惠活动在指定时间结束</li>
<li>创建的订单如果五分钟之后未支付关闭</li>
<li>…</li>
</ul>
<p>同时，需要对延时任务进行持久化。即，系统在意外宕机或者服务更新的情况下，延时任务依然可以重新装载。所以，这里关于非持久化实现方案（如使用Java的DelayQueue，Netty的时间轮片）不做考虑。本笔记主要从理论上论述两种实现方案。</p>
<a id="more"></a>


<h3 id="基于Redis的实现方案"><a href="#基于Redis的实现方案" class="headerlink" title="基于Redis的实现方案"></a>基于Redis的实现方案</h3><p>基于Redis的实现原理：利用Redis的Sorted Set数据结构，key作为任务类型，score作为要执行任务的时间，member作为消息体（如JSON格式的字符串），存储到Redis中。然后，开启一个定时任务，定时的去轮询score在区间[0, current]的元素（通过zrangebyscore实现），然后将查询到的任务交给新的线程去完成。需要注意的是：</p>
<ul>
<li>多个实例同时轮询，会出现一个任务多个地方消费的情况。所以，建议在执行任务前，通过zrem删除消息，保证只有一个实例执行任务。如果执行失败，还可以将消息再次写回到队列。当然，多实例的情况下也可以使用分布式锁实现消息的单一消费。</li>
<li>轮询引发的问题：假设5秒钟轮询一次且数据量足够大，而轮询一次执行完的时间远远大5秒，那么，就会造成在第一次轮询未完成的情况下，第二次轮询已经开始了。极端情况下，轮询任务一直叠加，最后会造成无限递归的情况，引发内存泄漏，系统崩溃。</li>
<li>Redis的消息无法进行监控。</li>
</ul>
<p>鉴于以上原因，Redis的方案不建议。</p>
<h3 id="基于RabbitMQ的实现方案"><a href="#基于RabbitMQ的实现方案" class="headerlink" title="基于RabbitMQ的实现方案"></a>基于RabbitMQ的实现方案</h3><p>网上很多文章说通过RabbitMQ的死信队列实现任务延时。这个死信队列有一个问题：队列的排序是根据消息进入的顺序排序。也就是说，假设第一个消息一小时后执行，第二个任务半小时后执行，但是因为第一个消息在前面，它会堵住所有后面的消息，直到它被消费掉。因此，死信队列的实现方案不予考虑。</p>
<p>最后选择的方案是，通过RabbitMQ的延时任务插件<code>abbitmq-delayed-message-exchange</code>实现。插件地址：<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange" target="_blank" rel="noopener">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a>。</p>
<p>延时任务支持的最大时长为<code>2^32-1=4294967295</code>毫秒（RabbitMQ是Erlang实现，Erlang的整形数据最大值就是2^32-1），约为50天左右。即，超过50天的延时任务，RabbitMQ可能无法做到。在Java中，<code>delayedTime</code>类型是int，Java中int的最大值为<code>2^31-1=2147483647</code>毫秒，约为25天左右。<br>对此，在Java中的处理该问题的方案如下：一般而言，数据库中存在一个结束时间（例如活动的结束时间），当延时的时间超过<code>Integer.MAX_VALUE</code>时，就设置延时时间为<code>Integer.MAX_VALUE</code>，在消费者接受到任务后，继续和结束时间进行对比，如果仍然超过int的最大值，则将消息原样放入到队列，延时时间为int的最大值，如此循环，直到延时时间小于int的最大值。</p>
<p>RabbitMQ中延时任务无法删除。只能通过消费者去对逻辑状态进行判断，从而丢弃掉无效的延时任务。例如，原延时任务定在15分钟后关闭订单，但是15分钟内用户支付完成，订单成功，则在消费者接受到任务是，对订单状态进行判断，如果成功，则丢弃该消息。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
</search>
