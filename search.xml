<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MacOS下编译OpenJDK8</title>
    <url>/2020/06/21/compile_openjdk8_on_macos/</url>
    <content><![CDATA[<p>已经连续下了好几天的大雨，不少地方应该涨洪水了，刚刚又看了下天气预报，接下来一个星期都是雨天，真是让人难过。周末在家无事，在家看书学习学习。最近在学习JVM，所以就先在自己的电脑上编译出一个JDK。折腾了一两天，可算成功了，这里对折腾过程中的踩的坑进行记录。</p>
<a id="more"></a>

<p><strong>写在前面：在源码中，有一个详细的安装指导手册 <code>README-builds.html</code> ，编译前应仔细阅读。这份文档囊括了网络上的绝大部分资料。</strong></p>
<h3 id="1-编译环境"><a href="#1-编译环境" class="headerlink" title="1 编译环境"></a>1 编译环境</h3><ul>
<li>macOS版本：<code>10.13.4 (17E199)</code></li>
<li>Xcode版本：<code>9.3.1</code></li>
</ul>
<blockquote>
<p>需要注意的是：JVM核心是由C/C++实现的，所以编译的时候需要用到gcc、g++。如果安装了xcode，则gcc和g++占用了纯正的gcc和g++。这里不需要去重新安装gcc和g++，直接使用Command Line Tools自带的clang即可。</p>
</blockquote>
<h3 id="2-获取源代码"><a href="#2-获取源代码" class="headerlink" title="2 获取源代码"></a>2 获取源代码</h3><p>OpenJDK8的源代码获取有多种方式。本人是通过github上的镜像获取到的。具体仓库地址： <code>git@github.com:AdoptOpenJDK/openjdk-jdk8u.git</code> 。由于commit的日志特别多，clone的时候可以使用 <code>--depth</code> 指定深度。分支使用master或dev均可。执行命令获取源代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:AdoptOpenJDK/openjdk-jdk8u.git</span><br><span class="line"># 如果不想获取过多的commit，加上--depth=1</span><br><span class="line">git clone --depth=1 git@github.com:AdoptOpenJDK/openjdk-jdk8u.git</span><br></pre></td></tr></table></figure>



<h3 id="3-安装依赖包"><a href="#3-安装依赖包" class="headerlink" title="3 安装依赖包"></a>3 安装依赖包</h3><p>目前必然使用到的依赖只有freetype，使用 <code>brew install freetype</code> 即可安装。其他依赖，看错误提示，缺啥就装啥。</p>
<h3 id="4-设置环境变量"><a href="#4-设置环境变量" class="headerlink" title="4 设置环境变量"></a>4 设置环境变量</h3><p>以下这份环境变量的设置主要来源于周志明的《深入理解Java虚拟机 JVM高级特性与最佳实践》一书。网络上的那几篇文章都是把这些环境变量设置到 <code>~/.bash_profile</code> 中，这样没有必要。因为这些环境变量，绝大多数只有本次编译是使用，编译完成后基本不会再用。所以这里建议在源码的根目录下新建一个 <code>env.sh</code> 文件，开启一个终端窗口，在该窗口下执行 <code>source env.sh</code> 。当然，如果终端关闭了，需要重新进入到源码根目录下，执行source命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设定语言选项，必须设置</span></span><br><span class="line">export LANG=C</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 这个是过时的环境变量，可以不设置</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># export ALT_BOOTDIR=/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 必须安装xcode，xcode已经把gcc g++命令占用了，直接重新装gcc重新设置编译可能会失败</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Mac平台，C编译器不再是GCC，是clang</span></span><br><span class="line">export CC=clang</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># C++编译器</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># export CXX=g++-4.9</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 跳过clang的一些严格的语法检查，不然会将N多的警告作为Error</span></span><br><span class="line">export COMPILER_WARNINGS_FATAL=false</span><br><span class="line"><span class="meta">#</span><span class="bash"> 链接时使用的参数</span></span><br><span class="line">export LFLAGS='-Xlinker -lstdc++'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否使用clang</span></span><br><span class="line">export USE_CLANG=true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用64位数据模型</span></span><br><span class="line">export LP64=1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 告诉编译平台是64位，不然会按32位来编译</span></span><br><span class="line">export ARCH_DATA_MODEL=64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许自动下载依赖</span></span><br><span class="line">export ALLOW_DOWNLOADS=true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 并行编译的线程数，编译时间长</span></span><br><span class="line">export HOTSPOT_BUILD_JOBS=2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否跳过与先前版本的比较</span></span><br><span class="line">export SKIP_COMPARE_IMAGES=true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否使用预编译头文件，加快编译速度</span></span><br><span class="line">export USE_PRECOMPILED_HEADER=true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否使用增量编译</span></span><br><span class="line">export INCREMENTAL_BUILD=true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译内容</span></span><br><span class="line">export BUILD_LANGTOOLS=true</span><br><span class="line">export BUILD_JAXP=true</span><br><span class="line">export BUILD_JAXWS=true</span><br><span class="line">export BUILD_CORBA=true</span><br><span class="line">export BUILD_HOTSPOT=true</span><br><span class="line">export BUILD_JDK=true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译版本</span></span><br><span class="line">export SKIP_DEBUG_BUILD=true</span><br><span class="line">export SKIP_FASTDEBUG_BUILD=false</span><br><span class="line">export DEBUG_NAME=debug</span><br><span class="line"><span class="meta">#</span><span class="bash"> 避开javaws和浏览器Java插件之类的部分的build</span></span><br><span class="line">export BUILD_DEPLOY=false</span><br><span class="line">export BUILD_INSTALL=false</span><br><span class="line">unset JAVA_HOME</span><br><span class="line">unset CLASSPATH</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面两个#号开头的行是本人的注释。另关于clang和gcc，需做进一步研究。</p>
</blockquote>
<h3 id="5-编译源码"><a href="#5-编译源码" class="headerlink" title="5 编译源码"></a>5 编译源码</h3><p>进入到源码openjdk-jdk8u下，先执行configure。可以通过 <code>chmod +x configure</code> 使文件具有可执行权限，或者使用 <code>bash</code> 执行脚本。然后执行 <code>make</code> 。</p>
<h4 id="5-1-configure"><a href="#5-1-configure" class="headerlink" title="5.1 configure"></a>5.1 configure</h4><p>configure执行的命令如下。这里执行freetype需要按照下面的命令，如果通过 <code>--with-freetype=$freetypeHome</code> 会一直报错（$freetypeHome是通过 <code>brew install freetype</code> 后的安装目录，一般在 <code>/usr/local/Cellar/freetype/version</code> 下）。分别指定include和lib目录就没有问题了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash configure --enable-debug --with-target-bits=64 --with-freetype-include=/usr/local/include/freetype2 --with-freetype-lib=/usr/local/lib/</span><br></pre></td></tr></table></figure>

<p>这里可能会出现下图的错误：</p>
<p><img src="/images/openjdk-1.jpg" alt=""></p>
<p>这是就是因为此gcc非彼gcc的原因。解决方案，找到 <code>common/autoconf/generated-configure.sh</code> ，将一下代码注释掉：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">    if test $? -ne 0; then</span><br><span class="line">      &#123; $as_echo "$as_me:$&#123;as_lineno-$LINENO&#125;: The $COMPILER_NAME compiler (located as $COMPILER) does not seem to be the required $TOOLCHAIN_TYPE compiler." &gt;&amp;5</span><br><span class="line"><span class="meta">$</span><span class="bash">as_echo <span class="string">"<span class="variable">$as_me</span>: The <span class="variable">$COMPILER_NAME</span> compiler (located as <span class="variable">$COMPILER</span>) does not seem to be the required <span class="variable">$TOOLCHAIN_TYPE</span> compiler."</span> &gt;&amp;6;&#125;</span></span><br><span class="line">      &#123; $as_echo "$as_me:$&#123;as_lineno-$LINENO&#125;: The result from running with --version was: \"$COMPILER_VERSION\"" &gt;&amp;5</span><br><span class="line"><span class="meta">$</span><span class="bash">as_echo <span class="string">"<span class="variable">$as_me</span>: The result from running with --version was: \"<span class="variable">$COMPILER_VERSION</span>\""</span> &gt;&amp;6;&#125;</span></span><br><span class="line">      as_fn_error $? "A $TOOLCHAIN_TYPE compiler is required. Try setting --with-tools-dir." "$LINENO" 5</span><br><span class="line">    fi</span><br></pre></td></tr></table></figure>

<p>全局搜索，应该有很多处需要注释，我搜出来有十个地方。无脑注释就行。注释完以后在按照前面的configure命令执行，最后得到以下结果意味着成了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Configuration summary:</span><br><span class="line">* Debug level:    fastdebug</span><br><span class="line">* JDK variant:    normal</span><br><span class="line">* JVM variants:   server</span><br><span class="line">* OpenJDK target: OS: macosx, CPU architecture: x86, address length: 64</span><br><span class="line"></span><br><span class="line">Tools summary:</span><br><span class="line">* Boot JDK:       java version &quot;1.8.0_144&quot; Java(TM) SE Runtime Environment (build 1.8.0_144-b01) Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)  (at /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home)</span><br><span class="line">* Toolchain:      gcc (GNU Compiler Collection)</span><br><span class="line">* C Compiler:     Version 4.9.4 (at /usr/local/bin/gcc-4.9)</span><br><span class="line">* C++ Compiler:   Version 4.9.4 (at /usr/local/bin/g++-4.9)</span><br><span class="line"></span><br><span class="line">Build performance summary:</span><br><span class="line">* Cores to use:   2</span><br><span class="line">* Memory limit:   8192 MB</span><br></pre></td></tr></table></figure>

<h4 id="5-2-make"><a href="#5-2-make" class="headerlink" title="5.2 make"></a>5.2 make</h4><p>上一步操作执行完没问题后，直接输入make执行即可。如果不出意外，应该会遇到一个关于 <code>-std=gnu++98</code>的坑，这里直接在文件 <code>common/autoconf/generated-configure.sh</code> 中找到行  <code>CXXSTD_CXXFLAG=&quot;-std=gnu++98&quot;</code> 注释掉即可。然后重新configure，再make。不出意外，最后得到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----- Build times -------</span><br><span class="line">Start 2020-06-21 16:38:55</span><br><span class="line">End   2020-06-21 16:58:41</span><br><span class="line">00:00:30 corba</span><br><span class="line">00:13:27 hotspot</span><br><span class="line">00:00:17 jaxp</span><br><span class="line">00:00:27 jaxws</span><br><span class="line">00:04:22 jdk</span><br><span class="line">00:00:42 langtools</span><br><span class="line">00:19:46 TOTAL</span><br><span class="line">-------------------------</span><br><span class="line">Finished building OpenJDK for target &apos;default&apos;</span><br></pre></td></tr></table></figure>

<p>执行下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build/macosx-x86_64-normal-server-fastdebug/jdk/bin &amp;&amp; ./java -version</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 得到如下结果</span></span><br><span class="line">openjdk version "1.8.0-internal-fastdebug"</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0-internal-fastdebug-vector_2020_06_21_16_38-b00)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.71-b00-fastdebug, mixed mode)</span><br></pre></td></tr></table></figure>

<p>大功告成。以上。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始手写一个MyBatis框架</title>
    <url>/2020/03/08/mini-mybatis/</url>
    <content><![CDATA[<p>MyBatis是在Java项目开发中，操作数据库环节时使用频率较高的ORM框架。疫情期间，闲来无事，就看了下其源码，探寻其底层实现，然后自己尝试实现一个简化版的MyBatis，以便更深入的学习和掌握。</p>
<a id="more"></a>

<h3 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1 预备知识"></a>1 预备知识</h3><ul>
<li>a. 掌握JDBC操作数据库的实现</li>
<li>b. 掌握Java动态代理的实现</li>
<li>c. XML文件的解析</li>
<li>d. MyBatis的基本使用</li>
</ul>
<p>本质上，MyBatis就是通过动态代理，对JDBC进行封装。所以，以上前两点是必须要掌握的。第三点，主要是解析MyBatis的配置文件和Mapper文件。第四点，我们的架构是模仿MyBatis，所以必须知道如何使用原生的MyBatis。本文最后的测试代码就是标准的MyBatis调用流程。</p>
<h3 id="2-架构梳理"><a href="#2-架构梳理" class="headerlink" title="2 架构梳理"></a>2 架构梳理</h3><p>MyBatis框架的流程如下图所示。</p>
<p><img src="/images/MyBatis.png" alt=""></p>
<p>我们对上图从上而下进行说明。</p>
<h4 id="2-1-Configuration"><a href="#2-1-Configuration" class="headerlink" title="2.1 Configuration"></a>2.1 Configuration</h4><p>MyBatis的配置文件分为两种。</p>
<ul>
<li>第一种是数据库的配置信息，比如数据库链接地址、账号密码之类。这些配置信息直接在Configuration中定义成员变量进行存储。</li>
<li>第二种就是Mapper配置信息，比如执行的SQL，入参，执行结果需要映射的类等等。这里通过一个HashMap去存储。key是Mapper接口的方法全路径（如：com.ums.demo.TagMapper.selectById），value是一个MappedStatement对象，该对象中包括执行的SQL，执行结果要映射的对象等等。</li>
</ul>
<p>总而言之，就是MyBatis的两种配置文件生成了一个Configuration对象。</p>
<h4 id="2-2-SqlSession"><a href="#2-2-SqlSession" class="headerlink" title="2.2 SqlSession"></a>2.2 SqlSession</h4><p>SqlSession对上层提供数据库操作接口。对真正的数据库操作之前做一些预处理。如，调用前，获得要执行的SQL（也就是获得一个MappedStatement），调用结束后，如果查询的是一条记录，而实际返回多条，则需要抛出异常。</p>
<p>这里使用到了工厂模式，所以有一个SqlSessionFactory类。这个工厂类做的事情就是实例化一个SqlSession。</p>
<h4 id="2-3-Executor"><a href="#2-3-Executor" class="headerlink" title="2.3 Executor"></a>2.3 Executor</h4><p>Executor是真正执行SQL的地方。对应JDBC的statement.executeQuery部分。SqlSession和Executor之间的关系，我们可以理解为在某些实际项目开发中Service层和Dao层之间的关系。</p>
<h4 id="2-4-ResultHandler"><a href="#2-4-ResultHandler" class="headerlink" title="2.4 ResultHandler"></a>2.4 ResultHandler</h4><p>ResultHandler就是将JDBC的查询结果ResultSet转换为对应的映射对象。</p>
<h4 id="2-5-MapperProxy"><a href="#2-5-MapperProxy" class="headerlink" title="2.5 MapperProxy"></a>2.5 MapperProxy</h4><p>这是MyBatis的动态代理实现的核心，上图中并未出现，但这里需要着重说明。当我们通过getMapper去获取一个Mapper接口的实现类的时候，返回的就是一个动态代理的MapperProxy对象。当调用Mapper的某个方法时，MapperProxy的实例对象得到方法的全路径名称，这样就可以去MappedStatement中获得要执行的SQL和返回结果映射对象等一系列信息。接下来就可以进入到SqlSession中一路往下执行了。</p>
<h3 id="3-开始实现"><a href="#3-开始实现" class="headerlink" title="3 开始实现"></a>3 开始实现</h3><p>这里我们设定一个实现目标：通过主键id查询数据库表中的一条记录。</p>
<p>由于涉及的代码较多，限于文章篇幅，这里只贴一些较为核心的代码。整个工程的代码详见<a href="https://github.com/vectooor/mini-mybatis" target="_blank" rel="noopener">github</a>。</p>
<p>首先，我们新建一个maven工程，引入以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 本次实现我们使用MySQL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- xml配置文件解析 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- xpath --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其次，建立如下图的工程目录结构（这里都是参照MyBatis的目录结构，类名也基本保持一致）：</p>
<p><img src="/images/mybatis-project.jpg" alt=""></p>
<p>Configuration将主要配置信息读取到成员变量中，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 数据库的链接信息 */</span></span><br><span class="line"><span class="keyword">private</span> String driverClassName;</span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户自定义的Mapper接口对应的xml路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; mappers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以methodName（packageName.className.methodName）作为key，MappedStatement作为value</span></span><br><span class="line"><span class="comment"> * mybatis源码也是类似的思想，mybatis的MappedStatement存储的内容更多，我们模仿时进行简化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, MappedStatement&gt; mappedStatements = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>动态代理部分的核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 这里可以做一些预处理</span></span><br><span class="line">    <span class="keyword">return</span> sqlSession.selectOne(mapperInterface.getName() + <span class="string">"."</span> + method.getName(), args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultSqlSession的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 构造函数将Configuration和Executor对象传入 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSession</span><span class="params">(Configuration configuration, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object[] args)</span> </span>&#123;</span><br><span class="line">    MappedStatement mappedStatement = configuration.getMappedStatement(statement);</span><br><span class="line">    List&lt;T&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        list = executor.query(mappedStatement, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"invoke executor cause exception: "</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TooManyResultsException(<span class="string">"Expected one result (or null) to be returned by selectOne(), but found: "</span> + list.size());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BaseExecutor准备好SQL，调用statement.executeQuery()，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement statement, Object[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        LOGGER.debug(<span class="string">"sql=[&#123;&#125;]"</span>, statement.getSql());</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(statement.getSql());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != args) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (args[<span class="number">0</span>] <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    preparedStatement.setString(i + <span class="number">1</span>, (String)args[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (args[<span class="number">0</span>] <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">                    preparedStatement.setInt(i + <span class="number">1</span>, (Integer) args[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 其他类型的参数依次类推</span></span><br><span class="line">                <span class="comment">// mybatis传入的参数有专门的类进行处理，我们这里未做任何处理，上层原样传入的参数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.debug(<span class="string">"params=[&#123;&#125;]"</span>, args);</span><br><span class="line">        preparedStatement.executeQuery();</span><br><span class="line"></span><br><span class="line">        DefaultResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(statement);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultSetHandler.handleResultSets(preparedStatement);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultResultSetHandler主要是将ResultSet转换为对应的对象，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ResultSet resultSet = stmt.getResultSet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;ResultMapping&gt; columns = mappedStatement.getResultMap().getColumns();</span><br><span class="line">    List&lt;E&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            E entity = (E) Class.forName(mappedStatement.getResultMap().getType()).newInstance();</span><br><span class="line">            <span class="keyword">for</span> (ResultMapping item : columns) &#123;</span><br><span class="line">                Field name = entity.getClass().getDeclaredField(item.getProperty());</span><br><span class="line">                name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"INTEGER"</span>.equals(item.getJdbcType())) &#123;</span><br><span class="line">                    name.set(entity, resultSet.getInt(item.getColumn()));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"VARCHAR"</span>.equals(item.getJdbcType())) &#123;</span><br><span class="line">                    name.set(entity, resultSet.getString(item.getColumn()));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"TIMESTAMP"</span>.equals(item.getJdbcType())) &#123;</span><br><span class="line">                    name.set(entity, resultSet.getDate(item.getColumn()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(entity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException | NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"result set handler cause exception: "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们在数据库中创建一张测试的表，建立好对应的实体类。最后的测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InputStream inputStream = AppTest.class.getClassLoader().getResourceAsStream("mini-mybatis-config.xml");</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    TagMapper tagMapper = sqlSession.getMapper(TagMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Tag tag = tagMapper.selectByPrimaryKey(<span class="number">2</span>);</span><br><span class="line">    LOGGER.info(tag.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就基本上实现了一个极简版的MyBatis。</p>
<p>单纯的在本文中看这些配置，可能较难理解。整个工程代码地址在这里：<a href="https://github.com/vectooor/mini-mybatis" target="_blank" rel="noopener">https://github.com/vectooor/mini-mybatis</a>。由于是学习代码，如果里面有部分错的代码，自己修正即可。</p>
<p>完。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中select、epoll的学习和理解</title>
    <url>/2020/01/07/linux-epoll/</url>
    <content><![CDATA[<p>近期在学习Java NIO，而后要进一步了解Netty，因为很多项目都用到Netty，所以，通过学习Java NIO的底层实现机制，可以更好的掌握。在Linux环境下，Java NIO实现底层是通过epoll。这里对相关学习资料进行整理。内容大部分来自网络。主要参考<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">链接</a>。</p>
<a id="more"></a>

<h3 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1 预备知识"></a>1 预备知识</h3><p>以下的每个知识点深入，都要涉及到更多更深的知识，这不在本文的范畴之内。这里只需要对这些概念进行一个宏观上的大致了解，便于理解接下来的文章主题即可。</p>
<ul>
<li>用户空间和内核空间</li>
<li>进程切换</li>
<li>进程阻塞</li>
<li>文件描述符</li>
<li>缓存I/O</li>
</ul>
<h4 id="1-1-用户空间和内核空间"><a href="#1-1-用户空间和内核空间" class="headerlink" title="1.1 用户空间和内核空间"></a>1.1 用户空间和内核空间</h4><p>简单来说，操作系统也是程序，其核心我们称之为内核（kernel），相应的用户自己编写的程序我们称之为用户程序。为了保证用户程序不能直接操作内核，保证内核的安全，操作系统将内存分为两个部分，一部分为内核空间，一部分为用户空间。针对Linux操作系统而言，将最高的1G字节（从虚拟地址<code>0xC0000000</code>到<code>0xFFFFFFFF</code>），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址<code>0x00000000</code>到<code>0xBFFFFFFF</code>），供各个进程使用，称为用户空间（假设内存为4G）。现在的操作系统都是采用<a href="https://www.zhihu.com/question/21088377" target="_blank" rel="noopener">虚拟存储器</a>。关于虚拟存储器，可以自行寻找资料进一步了解。</p>
<p><img src="/images/linux-architecture.png" alt=""></p>
<p>这里顺便说一下用户态和和内核态。</p>
<ul>
<li>内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。</li>
<li>用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。</li>
</ul>
<p>用户程序由用户态进入到内核态最直接的方式就是系统调用（<code>system call</code>）。</p>
<blockquote>
<p>这里个人有个疑问：用户态切到内核态非常耗资源（因为需要保存当前用户态的状态，进入到内核态执行，执行完毕后，需要将之前的用户态恢复），而CPU资源是通过内核进行管控的，用户态的程序需要使用CPU执行权，那岂不是无时无刻不在进行用户态到内核态的切换？</p>
<p>经多方资料查阅，得到如下答案：Linux下，CPU等级分为四级，Ring0~Ring3，内核态执行时，CPU权限级别为Ring0，可以访问所有资源；用户态执行时，CPU权限级别为Ring3。也就是说，CPU也存在内核态（Ring0）和用户态（Ring3）。Ring1和Ring2目前在Linux中暂未使用。</p>
</blockquote>
<h4 id="1-2-进程切换"><a href="#1-2-进程切换" class="headerlink" title="1.2 进程切换"></a>1.2 进程切换</h4><p>根据百度百科的解释：</p>
<blockquote>
<p>操作系统为了控制进程的执行，必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行，这种行为被称为进程切换，任务切换或上下文切换。</p>
</blockquote>
<p>进程的切换分为以下步骤：</p>
<ol>
<li>决定是否作上下文切换以及是否允许作上下文切换。</li>
<li>保存当前执行进程的上下文。</li>
<li>使用进程调度算法，选择一处于就绪状态的进程。</li>
<li>恢复或装配所选进程的上下文，将CPU控制权交到所选进程手中。</li>
</ol>
<p>总的一句话就是：<strong>进程切换很耗资源</strong>。</p>
<h4 id="1-3-进程阻塞"><a href="#1-3-进程阻塞" class="headerlink" title="1.3 进程阻塞"></a>1.3 进程阻塞</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语（Block），使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<strong>当进程进入阻塞状态，是不占用CPU资源的</strong>。</p>
<h4 id="1-4-文件描述符"><a href="#1-4-文件描述符" class="headerlink" title="1.4 文件描述符"></a>1.4 文件描述符</h4><p>在国内，也将文件描述符翻译为<strong>句柄</strong>。文件描述符维基百科的解释：</p>
<blockquote>
<p><strong>文件描述符</strong>（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
</blockquote>
<p>Linux的设计思想就是一切皆文件。我们经常打交道的文件好理解，比如一个日志文件，一个<code>.c</code>的源码文件等。对于建盘、屏幕、鼠标等外设，Linux中也将其视为文件，这有点神奇。<strong>Linux将一个Socket也视为一个文件</strong>。不要问为什么，这是规定。每个进程都有一个文件描述符表，同一进程不同文件描述符可能指向同一文件。</p>
<h4 id="1-5-缓存I-O"><a href="#1-5-缓存I-O" class="headerlink" title="1.5 缓存I/O"></a>1.5 缓存I/O</h4><p>缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存（page cache）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<p>缓存I/O的缺点：<em>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU以及内存开销是非常大的。</em></p>
<h3 id="2-IO模式"><a href="#2-IO模式" class="headerlink" title="2 IO模式"></a>2 IO模式</h3><p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p>正式因为这两个阶段，Linux系统产生了下面五种网络模式的方案。</p>
<ul>
<li>阻塞 I/O（blocking IO）</li>
<li>非阻塞 I/O（nonblocking IO）</li>
<li>I/O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I/O（ signal driven IO）</li>
<li>异步 I/O（asynchronous IO）</li>
</ul>
<p>注：由于signal driven IO在实际中并不常用，这里不讨论。</p>
<h4 id="2-1-阻塞I-O（blocking-IO）"><a href="#2-1-阻塞I-O（blocking-IO）" class="headerlink" title="2.1 阻塞I/O（blocking IO）"></a>2.1 阻塞I/O（blocking IO）</h4><p>在Linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p>
<p><img src="/images/blocking-io.png" alt=""></p>
<p>当用户进程调用了<code>recvfrom</code>这个系统调用，内核就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候内核就要等待完整的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当内核数据准备完毕，它就会将数据从内核中拷贝到用户内存，然后内核返回结果，用户进程才解除阻塞状态，重新运行起来。</p>
<p>所以，阻塞IO的特点就是两个阶段（等待、读取）都阻塞了。</p>
<blockquote>
<p>这里的读取操作是内存级别的操作，速度可达1Gb/s，可以理解为不耗时，也就是不阻塞。</p>
</blockquote>
<h4 id="2-2-非阻塞-I-O（nonblocking-IO）"><a href="#2-2-非阻塞-I-O（nonblocking-IO）" class="headerlink" title="2.2 非阻塞 I/O（nonblocking IO）"></a>2.2 非阻塞 I/O（nonblocking IO）</h4><p>Linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p>
<p><img src="/images/nonblocking-io.png" alt=""></p>
<p>当用户进程发出read操作时，如果内核中的数据还没有准备好，那么它并不会阻塞用户进程，而是立刻返回一个错误。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个错误时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户进程的系统调用，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p>所以，nonblocking IO的特点是用户进程需要不断的主动询问内核数据是否已准备完毕。</p>
<h4 id="2-3-多路复用I-O（-IO-multiplexing）"><a href="#2-3-多路复用I-O（-IO-multiplexing）" class="headerlink" title="2.3  多路复用I/O（ IO multiplexing）"></a>2.3  多路复用I/O（ IO multiplexing）</h4><p>IO multiplexing就是我们说的<code>select</code>，<code>poll</code>，<code>epoll</code>，有些地方也称这种IO方式为事件驱动IO（event driven IO）。<code>select/epoll</code>的好处就在于单个进程就可以同时处理多个网络连接的IO。它的基本原理就是<code>select</code>，<code>poll</code>，<code>epoll</code>这几函数会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p><img src="/images/multiplexing-io.png" alt=""></p>
<p><strong>当用户调用了<code>select</code>，那么整个进程就会阻塞。</strong>内核会”监视“所有<code>select</code>负责的socket，当任何一个socket中的数据准备好了，<code>select</code>就会返回。这个时候用户进程再调用read操作，将数据从内核拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，<code>select</code>函数就可以返回。</p>
<p>该模式的图，从表面上看，还不如阻塞IO的模型，因为阻塞IO只进行了一次系统调用，而这里进行了两次系统调用。但<code>select</code>的优势在于它能管理多个连接（connection）。所以，对于连接数较少的web服务器，<code>select、poll</code>的性能可能还不如阻塞IO的性能。</p>
<p>在多路复用I/O中，对于每个socket，一般都设置为非阻塞的。上图中，用户进程是阻塞的，但是是被<code>select</code>函数阻塞，而不是被socket阻塞。</p>
<h4 id="2-4-异步I-O（asynchronous-IO）"><a href="#2-4-异步I-O（asynchronous-IO）" class="headerlink" title="2.4 异步I/O（asynchronous IO）"></a>2.4 异步I/O（asynchronous IO）</h4><p>Linux下的asynchronous IO其实用得很少。先看一下它的流程：</p>
<p><img src="/images/asynchronous-io.png" alt=""></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何阻塞。然后，内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，内核会给用户进程发送一个信号（signal），告诉它read操作完成了。</p>
<h4 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h4><p>各个IO模型的比较如图所示：</p>
<p><img src="/images/linux-io-model-summary.png" alt=""></p>
<p>阻塞和非阻塞的区别：调用blocking IO会一直阻塞对应的进程直到操作完成，而non-blocking IO在内核还准备数据的情况下会立刻返回。</p>
<p>同步和异步的区别，根据POSIX的解释：</p>
<blockquote>
<p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</p>
<p>An asynchronous I/O operation does not cause the requesting process to be blocked;</p>
</blockquote>
<p>显然，上述的四种IO，除了异步IO，其他三个都属于同步IO。</p>
<h3 id="3-多路复用I-O之select、epoll详解"><a href="#3-多路复用I-O之select、epoll详解" class="headerlink" title="3 多路复用I/O之select、epoll详解"></a>3 多路复用I/O之select、epoll详解</h3><p>这里不对<code>select</code>和<code>epoll</code>的底层实现做过多描述，只是在宏观上理解两个函数的异同。</p>
<h4 id="3-1-select"><a href="#3-1-select" class="headerlink" title="3.1 select"></a>3.1 select</h4><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Check the first NFDS descriptors each in READFDS (if not NULL) for read</span></span><br><span class="line"><span class="comment">   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS</span></span><br><span class="line"><span class="comment">   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out</span></span><br><span class="line"><span class="comment">   after waiting the interval specified therein.  Returns the number of ready</span></span><br><span class="line"><span class="comment">   descriptors, or -1 for errors.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> __nfds, fd_set *__restrict __readfds,</span></span></span><br><span class="line"><span class="function"><span class="params">                   fd_set *__restrict __writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                   fd_set *__restrict __exceptfds,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct timeval *__restrict __timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后<code>select</code>函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
<p><code>select</code>的几大缺点：</p>
<ol>
<li><p>每次调用<code>select</code>，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；</p>
</li>
<li><p>同时每次调用<code>select</code>都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大；</p>
</li>
<li><p><code>select</code>支持的文件描述符数量太小了，默认是1024。</p>
</li>
</ol>
<h4 id="3-2-epoll"><a href="#3-2-epoll" class="headerlink" title="3.2 epoll"></a>3.2 epoll</h4><p>函数原型，可以在文件（<code>/usr/include/sys/epoll.h</code>）中找到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Creates an epoll instance.  Returns an fd for the new instance.</span></span><br><span class="line"><span class="comment">   The "size" parameter is a hint specifying the number of file</span></span><br><span class="line"><span class="comment">   descriptors to be associated with the new instance.  The fd</span></span><br><span class="line"><span class="comment">   returned by epoll_create() should be closed with close().  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">epoll_create</span> <span class="params">(<span class="keyword">int</span> __size)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Manipulate an epoll instance "epfd". Returns 0 in case of success,</span></span><br><span class="line"><span class="comment">   -1 in case of error ( the "errno" variable will contain the</span></span><br><span class="line"><span class="comment">   specific error code ) The "op" parameter is one of the EPOLL_CTL_*</span></span><br><span class="line"><span class="comment">   constants defined above. The "fd" parameter is the target of the</span></span><br><span class="line"><span class="comment">   operation. The "event" parameter describes which events the caller</span></span><br><span class="line"><span class="comment">   is interested in and any associated user data.  */</span></span><br><span class="line"><span class="comment">// 这里的__fd参数就是每次Socket连接建立以后的文件描述符</span></span><br><span class="line"><span class="comment">// 每次Socket建立以后得到一个__fd，然后在这里对__fd新注册读事件</span></span><br><span class="line"><span class="comment">// 读完以后对该fd的监测事件进行修改，修改为写事件</span></span><br><span class="line"><span class="comment">// 也就是说，__epfd句柄下，会有多个__fd</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">epoll_ctl</span> <span class="params">(<span class="keyword">int</span> __epfd, <span class="keyword">int</span> __op, <span class="keyword">int</span> __fd,</span></span></span><br><span class="line"><span class="function"><span class="params">                      struct epoll_event *__event)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for events on an epoll instance "epfd". Returns the number of</span></span><br><span class="line"><span class="comment">   triggered events returned in "events" buffer. Or -1 in case of</span></span><br><span class="line"><span class="comment">   error with the "errno" variable set to the specific error code. The</span></span><br><span class="line"><span class="comment">   "events" parameter is a buffer that will contain triggered</span></span><br><span class="line"><span class="comment">   events. The "maxevents" is the maximum number of events to be</span></span><br><span class="line"><span class="comment">   returned ( usually size of "events" ). The "timeout" parameter</span></span><br><span class="line"><span class="comment">   specifies the maximum wait time in milliseconds (-1 == infinite).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">epoll_wait</span> <span class="params">(<span class="keyword">int</span> __epfd, struct epoll_event *__events,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> __maxevents, <span class="keyword">int</span> __timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>epoll</code>是对<code>select</code>和<code>poll</code>的改进。在此之前，<code>select</code>和<code>poll</code>都只提供了一个函数——<code>select</code>或者<code>poll</code>函数。而<code>epoll</code>提供了三个函数，<code>epoll_create</code>、<code>epoll_ctl</code>和<code>epoll_wait</code>，<code>epoll_create</code>是创建一个<code>epoll</code>句柄；<code>epoll_ctl</code>是注册要监听的事件类型；<code>epoll_wait</code>则是等待事件的产生。</p>
<p>相较于<code>select</code>，<code>epoll</code>具备以下优点：</p>
<ol>
<li><p>没有最大并发连接的限制，能打开的fd的上限远大于1024（1G的内存上能监听约10万个端口）。</p>
</li>
<li><p>效率提升，不是轮询的方式，不会随着fd数目的增加效率下降。只有活跃可用的fd才会调用回调函数；即<code>epoll</code>最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，<code>epoll</code>的效率就会远远高于<code>select</code>和<code>poll</code>。</p>
</li>
<li><p>内存拷贝，利用mmap文件映射内存加速与内核空间的消息传递；即<code>epoll</code>使用mmap减少复制开销。</p>
</li>
</ol>
<h4 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h4><table>
<thead>
<tr>
<th>系统调用</th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody><tr>
<td>事件集合</td>
<td>用户通过3个参数分别传入感兴趣的可读，可写及异常等事件，内核通过对这些参数的在线修改来反馈其中的就绪事件这使得用户每次调用select都要重置这3个参数。</td>
<td>统一处理所有事件类型，因此只需要一个事件集参数。用户通过pollfd.events传入感兴趣的事件，内核通过修改pollfd.revents反馈其中就绪的事件</td>
<td>内核通过一个事件表直接管理用户感兴趣的所有事件。因此每次调用epoll_wait时，无需反复传入用户感兴趣的事件。epoll_wait系统调用的参数events仅用来反馈就绪的事件</td>
</tr>
<tr>
<td>应用程序索引就绪文件， 描述符的时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>最大支持文件描述符数</td>
<td>一般有最大值限制(默认1024)</td>
<td>65535</td>
<td>65535</td>
</tr>
<tr>
<td>工作模式</td>
<td>LT</td>
<td>LT</td>
<td>支持ET高效模式</td>
</tr>
<tr>
<td>内核实现和工作效率</td>
<td>采用轮询方式检测就绪事件，时间复杂度：O(n)</td>
<td>采用轮询方式检测就绪事件，时间复杂度：O(n)</td>
<td>采用回调方式检测就绪事件，时间复杂度：O(1)</td>
</tr>
</tbody></table>
<p>以上。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Socket</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下的awk、sed命令及正则表达式</title>
    <url>/2020/01/03/linux-awk-sed-and-regExp/</url>
    <content><![CDATA[<p>Linux提供了awk和sed两个强大的命令行文本处理工具，在对大型日志文件分析时特别有用。对文本的处理结合正则表达式可以高效的获取自己想要的日志信息。本文只是对awk、sed和正则表达式在笔者使用过程中遇到的一些比较常用的功能进行记录，更详细的使用方法可以去相应的官方网站查看。</p>
<a id="more"></a>

<h3 id="1-awk简单介绍"><a href="#1-awk简单介绍" class="headerlink" title="1 awk简单介绍"></a>1 awk简单介绍</h3><p>根据维基百科的<a href="https://zh.wikipedia.org/wiki/AWK" target="_blank" rel="noopener">介绍</a>：</p>
<blockquote>
<p>AWK是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一。这种编程及数据操作语言的最大功能取决于一个人所拥有的知识。AWK提供了极其强大的功能：可以进行正则表达式的匹配，样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。</p>
</blockquote>
<p>几乎所有的Linux都自带<code>awk</code>命令。它依次处理文件的每一行，并读取里面的每一个字段。对于日志文件那样的每行格式相同的文本文件，<code>awk</code>可能是最方便的工具。</p>
<h4 id="1-1-基本用法"><a href="#1-1-基本用法" class="headerlink" title="1.1 基本用法"></a>1.1 基本用法</h4><p>基本语法命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 格式</span><br><span class="line">$ awk actions fileName</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line">$ awk &apos;&#123;print $0&#125;&apos; test.log</span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>test.log</code>就是要处理的文本文件。<code>actions</code>即动作，写在一对单引号内，引号内的命令一般需要一对大括号括起来。<code>print</code>是打印命令。</p>
<p>根据以上的基础语法，我们进行一次实践。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里顺便学习<span class="built_in">echo</span>命令如何输出单引号，目前了解到的方式是通过双引号把单引号引起来，然后将单引号两侧的字符串通过单引号引起来，放在一起即可。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'I'</span><span class="string">"'"</span><span class="string">'m learning awk'</span> | awk <span class="string">'&#123;print $0&#125;'</span></span></span><br><span class="line">I'm learning awk</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'I'</span><span class="string">"'"</span><span class="string">'m learning awk'</span> | awk <span class="string">'&#123;print $1&#125;'</span></span></span><br><span class="line">I'm</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'I'</span><span class="string">"'"</span><span class="string">'m learning awk'</span> | awk <span class="string">'&#123;print $2&#125;'</span></span></span><br><span class="line">learning</span><br></pre></td></tr></table></figure>

<p>以上，我们可以看到，<code>$0</code>代表的是整行，<code>$1</code>默认为第一列，<code>$2</code>、<code>$3</code>以此类推。默认的分隔符是空格或制表符，即<code>\t</code>的转义字符。</p>
<p>为便于加深理解，我们以<code>/etc/passwd</code>文件（该文件是通过冒号分开的有规律的文件）为例，进行如下操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd | awk -F<span class="string">':'</span> <span class="string">'&#123;print $1&#125;'</span></span></span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br></pre></td></tr></table></figure>

<p>我们通过<code>-F</code>指定行的分隔符，然后输出每行的第一列。</p>
<h4 id="1-2-内置变量"><a href="#1-2-内置变量" class="headerlink" title="1.2 内置变量"></a>1.2 内置变量</h4><p>内置变量我们可以通过<code>man awk</code>命令，在结果中搜索<code>Built-in Variables</code>可以查询到所有的内置变量，这里对一些常用的做简单学习。</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>man手册解释</th>
<th>个人理解</th>
</tr>
</thead>
<tbody><tr>
<td>NF</td>
<td>The number of fields in the current input record.</td>
<td>当前行通过分隔符切割后一共有多少个字段。$NF就代表最后一个字段，相应的$(NF-1)就是倒数第二个字段。</td>
</tr>
<tr>
<td>NR</td>
<td>The total number of input records seen so far.</td>
<td>表示当前处理的是第几行。</td>
</tr>
<tr>
<td>FILENAME</td>
<td>The name of the current input file.  If no files are specified on the command line, the value of FILENAME is “-”.  However, FILENAME is undefined inside the BEGIN block (unless set by getline).</td>
<td>当前处理的文件的文件名。</td>
</tr>
<tr>
<td>FS</td>
<td>The input field separator, a space by default.</td>
<td>字段分隔符，默认是空格和制表符。</td>
</tr>
<tr>
<td>RS</td>
<td>The input record separator, by default a newline.</td>
<td>行的分隔符，默认是换行符。</td>
</tr>
</tbody></table>
<p>根据以上的内置变量，对其中的部分进行实践。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出第一列和倒数第二列，中间用字符-隔开，双引号中的字符原样输出，如果是逗号，默认为空格</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd | awk -F<span class="string">':'</span> <span class="string">'&#123;print $1"-"$(NF-1)&#125;'</span></span></span><br><span class="line">root-/root</span><br><span class="line">bin-/bin</span><br><span class="line">daemon-/sbin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同上，输出行号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd | awk -F<span class="string">':'</span> <span class="string">'&#123;print NR ")", $1, $(NF-1)&#125;'</span></span></span><br><span class="line">1) root /root</span><br><span class="line">2) bin /bin</span><br><span class="line">3) daemon /sbin</span><br></pre></td></tr></table></figure>

<h4 id="1-3-常用操作"><a href="#1-3-常用操作" class="headerlink" title="1.3 常用操作"></a>1.3 常用操作</h4><p>准备文件awk.txt，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 12</span><br><span class="line">2 32</span><br><span class="line">2 32</span><br><span class="line">5 12</span><br><span class="line">5 12</span><br><span class="line">6 165</span><br><span class="line">6 165</span><br></pre></td></tr></table></figure>

<p>我们分别对其进行求和和去重操作。</p>
<h5 id="1-3-1-求和"><a href="#1-3-1-求和" class="headerlink" title="1.3.1 求和"></a>1.3.1 求和</h5><p>我们对第二列的值进行求和操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN &#123;sum = 0&#125; &#123;sum += $2&#125; END &#123;print sum&#125;'</span> awk.txt </span></span><br><span class="line">430</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同样的，可以进行求平均值操作，除以总行数即可</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN &#123;sum = 0&#125; &#123;sum += $2&#125; END &#123;print sum/NR&#125;'</span> awk.txt</span></span><br><span class="line">61.4286</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 格式化输出，同C语言的格式化输出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN &#123;sum = 0&#125; &#123;sum += $2&#125; END &#123;printf("%.2f\n"), sum/NR&#125;'</span> awk.txt</span></span><br><span class="line">61.43</span><br></pre></td></tr></table></figure>

<h5 id="1-3-2-去重"><a href="#1-3-2-去重" class="headerlink" title="1.3.2 去重"></a>1.3.2 去重</h5><p>去重有两种方案可以实现。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先使用sort进行排序，然后进行uniq操作</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sort awk.txt | uniq</span></span><br><span class="line">1 12</span><br><span class="line">2 32</span><br><span class="line">5 12</span><br><span class="line">6 165</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用awk</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'!a[$0]++'</span> awk.txt</span></span><br><span class="line">1 12</span><br><span class="line">2 32</span><br><span class="line">5 12</span><br><span class="line">6 165</span><br></pre></td></tr></table></figure>

<p>关于<code>!a[$0]++</code>的个人理解：</p>
<ul>
<li><code>awk</code>数组的下标可以为字符串（经证实，可以。如果不可以，<code>a[$0]</code>也可以理解为下标=<code>hash($0)</code>）和数字。</li>
<li>如果action为空，默认<code>action={print $0}</code>，上面的去重命令行等价于<code>awk &#39;!a[$0]++ {print $0}&#39; awk.txt</code>。</li>
<li><code>++</code>操作是先使用值，然后自增。</li>
</ul>
<p>由以上三点，可以得出以下执行逻辑：</p>
<blockquote>
<p>读取<code>a[$0]</code>的值，默认为0，进行非操作<code>!a[$0]</code>得到值为1，所以输出<code>$0</code>然后值自增为1，下一次执行的时候，如果<code>a[$0] != 0</code>，进行非操作，得到<code>0</code>，则该行不输出。</p>
</blockquote>
<h5 id="1-3-2-条件筛选"><a href="#1-3-2-条件筛选" class="headerlink" title="1.3.2 条件筛选"></a>1.3.2 条件筛选</h5><p>如果我们切割出来的列，包含了一些杂质，比如，本来该列均为数字，结果文件内容该位置出现的字母，那么，我们可以进一步进行条件筛选。以如下文本为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 12</span><br><span class="line">2 32</span><br><span class="line">2 32</span><br><span class="line">5 12</span><br><span class="line">5 12</span><br><span class="line">6 165</span><br><span class="line">6 165</span><br><span class="line">h hello</span><br></pre></td></tr></table></figure>

<p>我们的需求是筛选出第二列的所有数字，实现方式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'&#123;tmp = $2&#125; &#123;if (tmp ~ /[0-9]+/) &#123;print $2&#125;&#125;'</span> awk.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者如下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'/[0-9]+/ &#123;print&#125;'</span> awk.txt </span></span><br><span class="line">1 12</span><br><span class="line">2 32</span><br><span class="line">2 32</span><br><span class="line">5 12</span><br><span class="line">5 12</span><br><span class="line">6 165</span><br><span class="line">6 165</span><br></pre></td></tr></table></figure>

<p><code>~</code>是<code>awk</code>中的正则表达式的匹配，相应的还有<code>!~</code>操作符。关于正则表达式，后面会花时间进行初步学习。</p>
<h3 id="2-sed实践"><a href="#2-sed实践" class="headerlink" title="2 sed实践"></a>2 sed实践</h3><p>对<code>sed</code>不着过多笔墨，这里只对实际场景中用到的进行简单记录。更深层次的学习后续用到的时候在这里继续补充。目前<code>sed</code>在实战中的使用场景是，在<code>shell</code>启动脚本中，读取配置文件的参数，然后通过命令启动应用。有如下配置文件<code>key=value</code>格式，我们需要通过key读取到value。</p>
<p>配置文件sed.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.name=api-service</span><br><span class="line">server.port=8080</span><br><span class="line">server.path=/test</span><br></pre></td></tr></table></figure>

<p>我们需要分别读到服务名称、端口等信息，具体操作如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 读取服务名称</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'/server.name/!d;s/.*=//'</span> sed.txt | tr -d <span class="string">'\r'</span></span></span><br><span class="line">api-service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取启动端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed <span class="string">'/server.port/!d;s/.*=//'</span> sed.txt | tr -d <span class="string">'\r'</span></span></span><br><span class="line">8080</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 依次类推</span></span><br></pre></td></tr></table></figure>

<p>对如上命令的理解和解释，在命令中以分号为界，分为两个部分：</p>
<ul>
<li><p>第一部分：<code>/server.name/!d</code></p>
<p><code>/server.name/</code>是一个正则表达式，表示包含字符串<code>server.name</code>的行，<code>d</code>是<code>sed</code>的一个删除命令操作，<code>!d</code>就是删除的反向操作，即删除所有不包含<code>server.name</code>字符串的行。执行<code>sed &#39;/server.name/!d&#39; sed.txt</code>可以得到<code>server.name=api-service</code>。</p>
</li>
<li><p>第二部分：<code>s/.*=//</code></p>
<p><code>s</code>在<code>sed</code>命令中的的含义为替换，后接的<code>/.*=/</code>是一个正则表达式，匹配的字符串为任何以<code>=</code>结尾的字符串，显然，这里匹配到的是<code>server.name=</code>。后面再接一个<code>/</code>，两个<code>/</code>之间的字符串为空，即将匹配到的字符串置为空，那么得到的结果就是<code>api-service</code>。</p>
</li>
</ul>
<p><code>tr</code>命令不在该文讨论范畴，可以自行查阅相关资料。这里的<code>tr -d &#39;\r&#39;</code>意思是删除末尾的换行符。</p>
<h3 id="3-正则表达式"><a href="#3-正则表达式" class="headerlink" title="3 正则表达式"></a>3 正则表达式</h3><p>该文已经较长，接下来单独开一篇学习正则表达式。</p>
<p>以上。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中Integer类型转String的注意事项</title>
    <url>/2019/12/02/java-integer-to-string/</url>
    <content><![CDATA[<p>在Java中，诸多场景都需要将Integer转为String的场景。之前图方便省事，直接 <code>+&quot;&quot;</code> 进行转化。今天特地对Integer转String进行适度的研究。（本文主要测试本地图片的引用方式）</p>
<a id="more"></a>

<h3 id="””操作"><a href="#””操作" class="headerlink" title="+””操作"></a>+””操作</h3><p>通过 <code>+&quot;&quot;</code> 进行实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer x = <span class="number">1</span>;</span><br><span class="line">        String s = x + <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，生成 <code>JVM.class</code> 文件，通过命令 <code>javap -verbose JVM.class</code> 查看，可以看到如下结果：</p>
<p><img src="/images/integer-to-string-pic1.png" alt=""></p>
<p>由此可以发现，通过 <code>+</code> 操作符连接一个空字符串的操作的时候，虚拟机实际的操作是新建了一个 <code>StringBuilder</code> 对象执行 <code>append</code> 操作去链接字符串。</p>
<h3 id="Integer-toString"><a href="#Integer-toString" class="headerlink" title="Integer.toString()"></a>Integer.toString()</h3><p>JDK的的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a &#123;<span class="doctag">@code</span> String&#125; object representing the</span></span><br><span class="line"><span class="comment"> * specified integer. The argument is converted to signed decimal</span></span><br><span class="line"><span class="comment"> * representation and returned as a string, exactly as if the</span></span><br><span class="line"><span class="comment"> * argument and radix 10 were given as arguments to the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #toString(int, int)&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   i   an integer to be converted.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a string representation of the argument in base&amp;nbsp;10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == Integer.MIN_VALUE)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-2147483648"</span>;</span><br><span class="line">    <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);</span><br><span class="line">    <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    getChars(i, size, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，针对Integer类型，专门实现了转String的方法。</p>
<h3 id="String-valueOf-int-i"><a href="#String-valueOf-int-i" class="headerlink" title="String.valueOf(int i)"></a>String.valueOf(int i)</h3><p>JDK的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the string representation of the &#123;<span class="doctag">@code</span> int&#125; argument.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The representation is exactly the one returned by the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Integer.toString&#125; method of one argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   i   an &#123;<span class="doctag">@code</span> int&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a string representation of the &#123;<span class="doctag">@code</span> int&#125; argument.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Integer#toString(int, int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String.valueOf</code> 还是调用了 <code>Integer.toString()</code> 。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>鉴于此，今后 <code>+&quot;&quot;</code> 的方案不建议使用。建议使用 <code>Integer.toString()</code> 或者 <code>String.valueOf()</code>。以上同样适用于Long、Double等类型的转换。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat返回头无OK字符的解决方案</title>
    <url>/2019/12/02/tomcat-response-without-OK-character/</url>
    <content><![CDATA[<p>公司业务架构升级，原来由PHP对外提供HTTP服务改为由SpringBoot（版本为2.1.3）提供，该版本默认的HTTP容器为Tomcat9，导致前端的返回头与原PHP返回的头不一致，从而引发前端一些老的接入终端出现问题。前端接入终端较多，切老旧设备的程序修改麻烦，所以必然需要后端来兼容前端。</p>
<a id="more"></a>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>PHP的返回头如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">date: Sat, 30 Nov 2019 13:53:42 GMT</span><br><span class="line">content-type: text/html;charset=UTF-8</span><br><span class="line">content-encoding: gzip</span><br></pre></td></tr></table></figure>
<p>改为Tomcat9以后，返回头如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200</span><br><span class="line">date: Sat, 30 Nov 2019 13:55:42 GMT</span><br><span class="line">content-type: text/html;charset=UTF-8</span><br><span class="line">content-encoding: gzip</span><br></pre></td></tr></table></figure>
<p>对比之下，发现Tomcat的返回少了“OK”两个字符。如果前端接入是较为高级一点的语言这不会有什么问题。但是对于一些比较古老的设备，基本上都是由C语言使用原生方式请求，接受到返回字符串后根据[HTTP/1.1 200 OK]去判断成功，否则报失败。这就相当坑爹了。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>经各方资料查阅，网络上这种文章都说通过配置tomcat的Connector参数<code>sendReasonPhrase=true</code>可以解决该问题。在tomcat的官方文档<code>https://tomcat.apache.org/tomcat-8.5-doc/config/http.html</code>找到关于<code>sendReasonPhrase</code>的如下描述：</p>
<blockquote>
<p>Set this attribute to true if you wish to have a reason phrase in the response. The default value is false.<br>Note: This option is deprecated and will be removed in Tomcat 9. The reason phrase will not be sent.</p>
</blockquote>
<p>由此，在Tomcat9中，该功能已经彻底无法实现了。所以只能通过降级到Tomcat8解决该问题。本人实测，降级到Tomcat8以后并设置<code>sendReasonPhrase=true</code>后该问题解决。Tomcat9尝试过添加该参数，无效。</p>
<p>需要注意的是，Tomcat有两种运行方式，一种是启动Tomcat，然后war包往webapps目录下扔即可。这种方式启动的直接在<code>$TOMCAT_HOME/conf/server.xml</code>中直接修改配置即可。<br>另一种是嵌入式的，比如在SpringBoot中是通过嵌入式方式启动的。对于这一种方式，要配置Tomcat的参数，需要实现接口<code>WebServerFactoryCustomizer</code>重写<code>customize</code>方法，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class PortalTomcatWebServerCustomizer implements WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void customize(TomcatServletWebServerFactory factory) &#123;</span><br><span class="line">        factory.addConnectorCustomizers(connector -&gt; connector.setAttribute(&quot;sendReasonPhrase&quot;, &quot;true&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>基于RabbitMQ的延时任务解决方案</title>
    <url>/2019/11/26/implement-delayed-task-by-rabbitmq/</url>
    <content><![CDATA[<p>公司的一个项目，有诸多场景需要用到延时任务，例如：</p>
<ul>
<li>创建的优惠活动在指定时间结束</li>
<li>创建的订单如果五分钟之后未支付关闭</li>
<li>…</li>
</ul>
<p>同时，需要对延时任务进行持久化。即，系统在意外宕机或者服务更新的情况下，延时任务依然可以重新装载。所以，这里关于非持久化实现方案（如使用Java的DelayQueue，Netty的时间轮片）不做考虑。本笔记主要从理论上论述两种实现方案。</p>
<a id="more"></a>


<h3 id="基于Redis的实现方案"><a href="#基于Redis的实现方案" class="headerlink" title="基于Redis的实现方案"></a>基于Redis的实现方案</h3><p>基于Redis的实现原理：利用Redis的Sorted Set数据结构，key作为任务类型，score作为要执行任务的时间，member作为消息体（如JSON格式的字符串），存储到Redis中。然后，开启一个定时任务，定时的去轮询score在区间[0, current]的元素（通过zrangebyscore实现），然后将查询到的任务交给新的线程去完成。需要注意的是：</p>
<ul>
<li>多个实例同时轮询，会出现一个任务多个地方消费的情况。所以，建议在执行任务前，通过zrem删除消息，保证只有一个实例执行任务。如果执行失败，还可以将消息再次写回到队列。当然，多实例的情况下也可以使用分布式锁实现消息的单一消费。</li>
<li>轮询引发的问题：假设5秒钟轮询一次且数据量足够大，而轮询一次执行完的时间远远大5秒，那么，就会造成在第一次轮询未完成的情况下，第二次轮询已经开始了。极端情况下，轮询任务一直叠加，最后会造成无限递归的情况，引发内存泄漏，系统崩溃。</li>
<li>Redis的消息无法进行监控。</li>
</ul>
<p>鉴于以上原因，Redis的方案不建议。</p>
<h3 id="基于RabbitMQ的实现方案"><a href="#基于RabbitMQ的实现方案" class="headerlink" title="基于RabbitMQ的实现方案"></a>基于RabbitMQ的实现方案</h3><p>网上很多文章说通过RabbitMQ的死信队列实现任务延时。这个死信队列有一个问题：队列的排序是根据消息进入的顺序排序。也就是说，假设第一个消息一小时后执行，第二个任务半小时后执行，但是因为第一个消息在前面，它会堵住所有后面的消息，直到它被消费掉。因此，死信队列的实现方案不予考虑。</p>
<p>最后选择的方案是，通过RabbitMQ的延时任务插件<code>abbitmq-delayed-message-exchange</code>实现。插件地址：<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange" target="_blank" rel="noopener">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a>。</p>
<p>延时任务支持的最大时长为<code>2^32-1=4294967295</code>毫秒（RabbitMQ是Erlang实现，Erlang的整形数据最大值就是2^32-1），约为50天左右。即，超过50天的延时任务，RabbitMQ可能无法做到。在Java中，<code>delayedTime</code>类型是int，Java中int的最大值为<code>2^31-1=2147483647</code>毫秒，约为25天左右。<br>对此，在Java中的处理该问题的方案如下：一般而言，数据库中存在一个结束时间（例如活动的结束时间），当延时的时间超过<code>Integer.MAX_VALUE</code>时，就设置延时时间为<code>Integer.MAX_VALUE</code>，在消费者接受到任务后，继续和结束时间进行对比，如果仍然超过int的最大值，则将消息原样放入到队列，延时时间为int的最大值，如此循环，直到延时时间小于int的最大值。</p>
<p>RabbitMQ中延时任务无法删除。只能通过消费者去对逻辑状态进行判断，从而丢弃掉无效的延时任务。例如，原延时任务定在15分钟后关闭订单，但是15分钟内用户支付完成，订单成功，则在消费者接受到任务是，对订单状态进行判断，如果成功，则丢弃该消息。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
</search>
