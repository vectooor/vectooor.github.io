<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Tomcat返回头无OK字符的解决方案</title>
    <url>/2019/11/30/tomcat-response-without-OK-character/</url>
    <content><![CDATA[<p>公司业务架构升级，原来由PHP对外提供HTTP服务改为由SpringBoot（版本为2.1.3）提供，该版本默认的HTTP容器为Tomcat9，导致前端的返回头与原PHP返回的头不一致，从而引发前端一些老的接入终端出现问题。前端接入终端较多，切老旧设备的程序修改麻烦，所以必然需要后端来兼容前端。</p>
<a id="more"></a>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>PHP的返回头如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">date: Sat, 30 Nov 2019 13:53:42 GMT</span><br><span class="line">content-type: text/html;charset=UTF-8</span><br><span class="line">content-encoding: gzip</span><br></pre></td></tr></table></figure>
<p>改为Tomcat9以后，返回头如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200</span><br><span class="line">date: Sat, 30 Nov 2019 13:55:42 GMT</span><br><span class="line">content-type: text/html;charset=UTF-8</span><br><span class="line">content-encoding: gzip</span><br></pre></td></tr></table></figure>
<p>对比之下，发现Tomcat的返回少了“OK”两个字符。如果前端接入是较为高级一点的语言这不会有什么问题。但是对于一些比较古老的设备，基本上都是由C语言使用原生方式请求，接受到返回字符串后根据[HTTP/1.1 200 OK]去判断成功，否则报失败。这就相当坑爹了。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>经各方资料查阅，网络上这种文章都说通过配置tomcat的Connector参数<code>sendReasonPhrase=true</code>可以解决该问题。在tomcat的官方文档<code>https://tomcat.apache.org/tomcat-8.5-doc/config/http.html</code>找到关于<code>sendReasonPhrase</code>的如下描述：</p>
<blockquote>
<p>Set this attribute to true if you wish to have a reason phrase in the response. The default value is false.<br>Note: This option is deprecated and will be removed in Tomcat 9. The reason phrase will not be sent.</p>
</blockquote>
<p>由此，在Tomcat9中，该功能已经彻底无法实现了。所以只能通过降级到Tomcat8解决该问题。降级到Tomcat8以后实测解决该问题。</p>
<p>需要注意的是，Tomcat有两种运行方式，一种是启动Tomcat，然后war包往webapps目录下扔即可。这种方式启动的直接在<code>$TOMCAT_HOME/conf/server.xml</code>中直接修改配置即可。<br>另一种是嵌入式的，比如在SpringBoot中是通过嵌入式方式启动的。对于这一种方式，要配置Tomcat的参数，需要继承类<code>TomcatServletWebServerFactory</code>重写其中一个方法。(待补充，现在忘了)</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>基于RabbitMQ的延时任务解决方案</title>
    <url>/2019/11/26/implement-delayed-task-by-rabbitmq/</url>
    <content><![CDATA[<p>公司的一个项目，有诸多场景需要用到延时任务，例如：</p>
<ul>
<li>创建的优惠活动在指定时间结束</li>
<li>创建的订单如果五分钟之后未支付关闭</li>
<li>…</li>
</ul>
<p>同时，需要对延时任务进行持久化。即，系统在意外宕机或者服务更新的情况下，延时任务依然可以重新装载。所以，这里关于非持久化实现方案（如使用Java的DelayQueue，Netty的时间轮片）不做考虑。本笔记主要从理论上论述两种实现方案。</p>
<a id="more"></a>


<h3 id="基于Redis的实现方案"><a href="#基于Redis的实现方案" class="headerlink" title="基于Redis的实现方案"></a>基于Redis的实现方案</h3><p>基于Redis的实现原理：利用Redis的Sorted Set数据结构，key作为任务类型，score作为要执行任务的时间，member作为消息体（如JSON格式的字符串），存储到Redis中。然后，开启一个定时任务，定时的去轮询score在区间[0, current]的元素（通过zrangebyscore实现），然后将查询到的任务交给新的线程去完成。需要注意的是：</p>
<ul>
<li>多个实例同时轮询，会出现一个任务多个地方消费的情况。所以，建议在执行任务前，通过zrem删除消息，保证只有一个实例执行任务。如果执行失败，还可以将消息再次写回到队列。当然，多实例的情况下也可以使用分布式锁实现消息的单一消费。</li>
<li>轮询引发的问题：假设5秒钟轮询一次且数据量足够大，而轮询一次执行完的时间远远大5秒，那么，就会造成在第一次轮询未完成的情况下，第二次轮询已经开始了。极端情况下，轮询任务一直叠加，最后会造成无限递归的情况，引发内存泄漏，系统崩溃。</li>
<li>Redis的消息无法进行监控。</li>
</ul>
<p>鉴于以上原因，Redis的方案不建议。</p>
<h3 id="基于RabbitMQ的实现方案"><a href="#基于RabbitMQ的实现方案" class="headerlink" title="基于RabbitMQ的实现方案"></a>基于RabbitMQ的实现方案</h3><p>网上很多文章说通过RabbitMQ的死信队列实现任务延时。这个死信队列有一个问题：队列的排序是根据消息进入的顺序排序。也就是说，假设第一个消息一小时后执行，第二个任务半小时后执行，但是因为第一个消息在前面，它会堵住所有后面的消息，直到它被消费掉。因此，死信队列的实现方案不予考虑。</p>
<p>最后选择的方案是，通过RabbitMQ的延时任务插件<code>abbitmq-delayed-message-exchange</code>实现。插件地址：<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange" target="_blank" rel="noopener">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a>。</p>
<p>延时任务支持的最大时长为<code>2^32-1=4294967295</code>毫秒（RabbitMQ是Erlang实现，Erlang的整形数据最大值就是2^32-1），约为50天左右。即，超过50天的延时任务，RabbitMQ可能无法做到。在Java中，<code>delayedTime</code>类型是int，Java中int的最大值为<code>2^31-1=2147483647</code>毫秒，约为25天左右。<br>对此，在Java中的处理该问题的方案如下：一般而言，数据库中存在一个结束时间（例如活动的结束时间），当延时的时间超过<code>Integer.MAX_VALUE</code>时，就设置延时时间为<code>Integer.MAX_VALUE</code>，在消费者接受到任务后，继续和结束时间进行对比，如果仍然超过int的最大值，则将消息原样放入到队列，延时时间为int的最大值，如此循环，直到延时时间小于int的最大值。</p>
<p>RabbitMQ中延时任务无法删除。只能通过消费者去对逻辑状态进行判断，从而丢弃掉无效的延时任务。例如，原延时任务定在15分钟后关闭订单，但是15分钟内用户支付完成，订单成功，则在消费者接受到任务是，对订单状态进行判断，如果成功，则丢弃该消息。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
</search>
