<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="Vectooor" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="本文主要记录学习Spring中一些关键笔记。主要包括容器初始化、Bean的生命周期、循环依赖、事件机制等。">
<meta name="keywords" content="Spring">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring学习笔记">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;04&#x2F;spring&#x2F;index.html">
<meta property="og:site_name" content="Vectooor">
<meta property="og:description" content="本文主要记录学习Spring中一些关键笔记。主要包括容器初始化、Bean的生命周期、循环依赖、事件机制等。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-08-04T06:18:08.470Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2021/08/04/spring/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Spring学习笔记 | Vectooor</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vectooor</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">talk is cheap, show me the code</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/04/spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile-photo.jpg">
      <meta itemprop="name" content="勤恳的小码农">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vectooor">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-04 14:16:43 / 修改时间：14:18:08" itemprop="dateCreated datePublished" datetime="2021-08-04T14:16:43+08:00">2021-08-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">评论：</span>
    
    <a title="valine" href="/2021/08/04/spring/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/08/04/spring/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              <span>20k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文主要记录学习Spring中一些关键笔记。主要包括容器初始化、Bean的生命周期、循环依赖、事件机制等。</p>
<a id="more"></a>

<h3 id="1-容器初始化"><a href="#1-容器初始化" class="headerlink" title="1 容器初始化"></a>1 容器初始化</h3><ul>
<li>1）<code>Resource</code>的定位。<br>在整个应用中找寻关于Bean的定义，比如xml文件的<code>&lt;bean/&gt;</code>标签，类的<code>Component</code>注解等；</li>
<li>2）<code>BeanDefinition</code>的载入。<br>将步骤一中寻找的Bean的定义，将其解析成Spring框架所抽象定义的数据结构：<code>BeanDefinition</code>；</li>
<li>3）<code>BeanDefinition</code>的注册。<br>本质上就是将步骤二中解析出来的数据格式<code>put</code>到<code>BeanFactory</code>的一个<code>HaspMap</code>中。</li>
</ul>
<h3 id="2-Bean生命周期"><a href="#2-Bean生命周期" class="headerlink" title="2 Bean生命周期"></a>2 Bean生命周期</h3><p>以下的三个方法可以在类<code>AbstractAutowireCapableBeanFactory</code>的方法<code>doCreateBean</code>中找到。</p>
<h4 id="2-1-createBeanInstance"><a href="#2-1-createBeanInstance" class="headerlink" title="2.1 createBeanInstance"></a>2.1 <code>createBeanInstance</code></h4><p>创建实例，为对象分配内存空间。该方法的源码注释如下：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Create a <span class="keyword">new</span> instance <span class="keyword">for</span> the specified bean, using an appropriate instantiation strategy: factory method, constructor autowiring, or simple instantiation.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里需要关注接口<code>InstantiationAwareBeanPostProcessor</code>，该接口提供了实例化前后的操作入口。其中方法<code>postProcessBeforeInstantiation()</code>会在实例化之前执行。根据源码追踪会发现，如果该方法的返回值不为<code>null</code>，则执行<code>postProcessAfterInstantiation()</code>，然后返回对象，<strong><code>createBeanInstance</code>压根就没有执行！！！</strong>（代理发生在这里？）</p>
<h4 id="2-2-populateBean"><a href="#2-2-populateBean" class="headerlink" title="2.2 populateBean"></a>2.2 <code>populateBean</code></h4><p>为实例的属性赋值。<code>populate</code>这里可以翻译为<code>植入</code>。循环依赖就发生在这个位置。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Populate the bean instance in the given BeanWrapper with the property values from the bean definition.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在这个方法执行前，会执行接口<code>InstantiationAwareBeanPostProcessor</code>的<code>postProcessAfterInstantiation()</code>方法，这个方法的返回值是<code>boolean</code>类型。如果返回<code>false</code>，可以阻断属性的赋值操作。</p>
<h4 id="2-3-initializeBean"><a href="#2-3-initializeBean" class="headerlink" title="2.3 initializeBean"></a>2.3 <code>initializeBean</code></h4><p>  初始化。</p>
<p>  首先，执行<code>BeanPostProcessor.postProcessBeforeInitialization()</code>；</p>
<p>  其次，如果实现了<code>InitializingBean</code>，那么<code>InitializingBean.afterPropertiesSet()</code>先执行；</p>
<p>  然后，如果指定了<code>initMethod</code>，那么执行初始化方法；(如xml中<code>bean</code>标签的<code>init-method</code>属性)</p>
<p>  最后，执行<code>BeanPostProcessor.postProcessAfterInitialization()</code>。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Initialize the given bean instance, applying factory callbacks as well as init methods and bean post processors.</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-4-destroy"><a href="#2-4-destroy" class="headerlink" title="2.4 destroy"></a>2.4 <code>destroy</code></h4><p>销毁。首先，如果存在<code>DestructionAwareBeanPostProcessor</code>，则会在销毁前执行该接口的方法<code>postProcessBeforeDestruction</code>；其次，如果Bean实现了接口<code>DisposableBean</code>，则执行它的<code>destroy</code>方法；最后，执行自定义的销毁方法。</p>
<h3 id="3-Bean的循环依赖"><a href="#3-Bean的循环依赖" class="headerlink" title="3 Bean的循环依赖"></a>3 Bean的循环依赖</h3><h4 id="3-1-循环注入流程"><a href="#3-1-循环注入流程" class="headerlink" title="3.1 循环注入流程"></a>3.1 循环注入流程</h4><p>针对循环依赖，通过构造器的方式注入依赖的Bean是无法实现的。并且，如果Bean不是单例的，循环依赖也无法实现（因为Spring不会对非单例的Bean进行缓存）。所以，Spring解决循环依赖的前提条件是：<strong>Bean是单例的，且通过setter的方式注入</strong>。</p>
<p>Spring通过三级缓存的方式解决循环依赖的问题（Spring对此并没有缓存的概念，应该是国内为了方便理解，而增加的概念，但这都不是重点）。首先，三级缓存的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法所在的类：org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一级缓存，所有已经实例化完成的Bean都会放在这里</span></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级缓存：早期暴露的bean的缓存</span></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三级缓存：单例bean工厂的缓存</span></span><br><span class="line"><span class="comment">// 这里的ObjectFactory是AbstractAutowireCapableBeanFactory.getEarlyBeanReference</span></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>先给定一个循环依赖的代码示例，方便后面的理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClazzA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClazzB clazzB;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClazzB</span><span class="params">(ClazzB clazzB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clazzB = clazzB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClazzB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClazzA clazzA;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClazzA</span><span class="params">(ClazzA clazzA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clazzA = clazzA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在启动容器，首先构造ClazzA，执行到如下流程（剔除影响阅读的代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.beans.factory.support.AbstractBeanFactory</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">                          @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.查看缓存中是否已经有这个bean了</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName); <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若缓存中不存在，准备创建这个bean</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">// 2.下面进入单例bean的创建过程</span></span><br><span class="line">            sharedInstance = getSingleton(beanName, () -&gt; &#123; <span class="comment">// @2</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码<strong>@1</strong>的地方，获取Bean的主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、先从一级缓存中找</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 2、一级缓存找不到，到二级缓存中找</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">// 3、二级缓存没找到，到三级缓存中找</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 三级缓存是一个工厂，执行工厂的方法，获得Bean</span></span><br><span class="line">                    <span class="comment">// 这里的singletonFactory是在AbstractAutowireCapableBeanFactory.doCreateBean方法中</span></span><br><span class="line">                    <span class="comment">// 调用addSingletonFactory时，缓存的Lamda表达式：() -&gt; getEarlyBeanReference(beanName, mbd, bean)</span></span><br><span class="line">                    <span class="comment">// 也就是说，这里执行完的得到的Bean还没有执行populateBean</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">// 三级缓存创建好的Bean放到二级缓存中</span></span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="comment">// 移除三级缓存中该Bean的缓存</span></span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，这个时候ClazzA肯定找不到，所以走到创建流程<strong>@2</strong>的位置，再次进入到<code>getSingleton</code>的重载方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 单例bean创建之前调用，将其加入正在创建的列表中，上面有提到过，主要用来检测循环依赖用的</span></span><br><span class="line">            <span class="comment">// singletonsCurrentlyInCreation.add(beanName)</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用工厂创建bean</span></span><br><span class="line">                singletonObject = singletonFactory.getObject(); <span class="comment">// @1</span></span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 单例bean创建之后调用，主要是将其从正在创建的列表中移除</span></span><br><span class="line">                <span class="comment">// singletonsCurrentlyInCreation.remove(beanName)</span></span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">// 将创建好的单例bean放入一级缓存中，二级三级缓存清除</span></span><br><span class="line">                <span class="comment">//-------------------------------------</span></span><br><span class="line">                <span class="comment">// this.singletonObjects.put(beanName, singletonObject);</span></span><br><span class="line">                <span class="comment">// this.singletonFactories.remove(beanName);</span></span><br><span class="line">                <span class="comment">// this.earlySingletonObjects.remove(beanName);</span></span><br><span class="line">                <span class="comment">// this.registeredSingletons.add(beanName);</span></span><br><span class="line">                <span class="comment">//-------------------------------------</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面<strong>@1</strong>的位置，最终会执行到下面的代码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                         <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//-------------------------------------</span></span><br><span class="line">        <span class="comment">// // 第1级缓存中不存在bean</span></span><br><span class="line">        <span class="comment">// if (!this.singletonObjects.containsKey(beanName)) &#123;</span></span><br><span class="line">        <span class="comment">//    // 将其丢到第3级缓存中</span></span><br><span class="line">        <span class="comment">//    this.singletonFactories.put(beanName, singletonFactory);</span></span><br><span class="line">        <span class="comment">//    // 后面的2行代码不用关注</span></span><br><span class="line">        <span class="comment">//    this.earlySingletonObjects.remove(beanName);</span></span><br><span class="line">        <span class="comment">//    this.registeredSingletons.add(beanName);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//-------------------------------------</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean)); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码<code>addSingletonFactory</code>执行完后就将classA放入到三级缓存中了。然后开始注入属性，注入的时候发现依赖ClazzB，这时候又递归回去，继续一遍上面创建Bean的流程，这一次是创建clazzB。然后clazzB去获取clazzA的时候在三级缓存中拿到了clazzA，并且将clazzA移到二级缓存（此时的clazzA还没有执行populate，是一个半成品），然后注入，完成clazzB的注册。这时，clazzA拿到了clazzB，完成注册，最后将自己注册到一级缓存中。</p>
<blockquote>
<p>整个流程如下：</p>
<ul>
<li>从容器中获取clazzA</li>
<li>容器尝试从3个缓存中找classA，找不到</li>
<li>准备创建clazzA</li>
<li>调用classA的构造器创建classA，得到classA实例，此时classA还未填充属性，未进行其他任何初始化的操作</li>
<li>将早期的classA暴露出去：即将其丢到第3级缓存singletonFactories中</li>
<li>classA准备填充属性，发现需要注入clazzB，然后向容器获取clazzB</li>
<li>容器尝试从3个缓存中找clazzB，找不到</li>
<li>准备创建clazzB</li>
<li>调用ClazzB的构造器创建clazzB，得到clazzB实例，此时clazzB还未填充属性，未进行其他任何初始化的操作</li>
<li>将早期的clazzB暴露出去：即将其丢到第3级缓存singletonFactories中</li>
<li>clazzB准备填充属性，发现需要注入clazzA，然后向容器获取clazzA</li>
<li>容器尝试从3个缓存中找clazzA，发现此时clazzA位于第3级缓存中，经过处理之后，clazzA会从第3级缓存中移除，然后会存到第2级缓存中，然后将其返回给clazzB，此时clazzA通过clazzB中的setClazzA方法被注入到clazzB中</li>
<li>clazzB继续执行后续的一些操作，最后完成创建工作，然后会调用addSingleton方法，将自己丢到第1级缓存中，并将自己从第2和第3级缓存中移除</li>
<li>clazzB将自己返回给clazzA</li>
<li>clazzA通过setClazzB方法将clazzB注入进去</li>
<li>ClazzA继续执行后续的一些操作，最后完成创建工作，然后会调用addSingleton方法，将自己丢到第1级缓存中，并将自己从第2和第3级缓存中移除</li>
</ul>
</blockquote>
<p>以上就是结合源码，厘清Spring循环依赖的注入流程。</p>
<h4 id="3-2-为什么要三级缓存"><a href="#3-2-为什么要三级缓存" class="headerlink" title="3.2 为什么要三级缓存"></a>3.2 为什么要三级缓存</h4><p><strong>如果只使用2级缓存，直接将刚实例化好的bean暴露给二级缓存是否可以达到循环依赖的效果？</strong></p>
<p>答案是：<strong>这样做是可以解决，但是存在一个问题：早期暴露给其他依赖者的bean和最终暴露的bean不一致的问题。</strong></p>
<p>若将刚刚实例化好的bean直接丢到二级缓存中暴露出去，如果后期这个bean对象被更改了，比如可能在上面加了一些拦截器，将其包装为一个代理了，那么暴露出去的bean和最终的这个bean就不一样的，将自己暴露出去的时候是一个原始对象，而自己最终却是一个代理对象，最终会导致被暴露出去的和最终的bean不是同一个bean的，将产生意想不到的效果，而三级缓存就可以发现这个问题，会报错。</p>
<p>那么，三级缓存是如何解决这个问题的？看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean</span></span><br><span class="line"><span class="comment">// 这段代码在initializeBean之后，也就是说，这段检测代码是在Bean初始化完成后</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="comment">// 注意第二个参数是false，则意味着只会从第一级和第二级缓存中获取对象</span></span><br><span class="line">    <span class="comment">// 如果从能够获取到，这说明第二级缓存中已经存在这个Bean了。</span></span><br><span class="line">    <span class="comment">//（为什么是第二级存在？因为需要等到本段代码所在的方法执行完以后，才会放到第一级中去）</span></span><br><span class="line">    <span class="comment">// 第二级中存在，这意味着第三级缓存已经有人取过了。</span></span><br><span class="line">    Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// bean是实例化以后的Bean</span></span><br><span class="line">        <span class="comment">// exposedObject是初始化以后的Bean</span></span><br><span class="line">        <span class="comment">// exposedObject == bean则意味着实例化和初始化以后，对象并没有改变</span></span><br><span class="line">        <span class="comment">// 根据Bean的生命周期，我们知道，假设实例化之后Bean是@1234，则初始化调用BeanPostProcessor执行代理可能得到一个@5678的对象</span></span><br><span class="line">        <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">            <span class="comment">// 这里的赋值没看懂</span></span><br><span class="line">            exposedObject = earlySingletonReference;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果初始化完成后，Bean发生了改变，在检测配置allowRawInjectionDespiteWrapping</span></span><br><span class="line">        <span class="comment">// 参数allowRawInjectionDespiteWrapping的意思是：</span></span><br><span class="line">        <span class="comment">// 是否允许早期给别人使用的bean和最终bean不一致的情况，这个值默认是false，表示不允许，</span></span><br><span class="line">        <span class="comment">// 也就是说暴露给别人的bean和最终的bean是需要一致的。</span></span><br><span class="line">        <span class="comment">// 如果要改变这个参数的值，则注册一个BeanFactoryPostProcessor，在接口实现中修改该参数的值即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">            <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                    actualDependentBeans.add(dependentBean);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 这里省略了异常日志</span></span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, <span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，在循环依赖存在的情况下，假设发生了代理，该如何实现才能让初始化完成前后，得到的是同一个对象呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getEarlyBeanReference</span></span><br><span class="line"><span class="comment">// 这个方法是三级缓存ObjectFactory缓存的对象。</span></span><br><span class="line"><span class="comment">// 如果要达到上面问题的效果，则只需要将代理逻辑实现在SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference中即可</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于循环依赖的部分结束。这部分代码主要参考了路人甲的文章<a href="https://mp.weixin.qq.com/s/pQaX2-BqFsO3pzPELWIDfQ" target="_blank" rel="noopener">Bean循环依赖详解</a>。他的文章还有示例，更加详细。</p>
<h3 id="4-事件机制"><a href="#4-事件机制" class="headerlink" title="4 事件机制"></a>4 事件机制</h3><p>事件机制的本质是观察者模式的具体实现。Spring的事件机制可以很好的实现业务逻辑的解耦。比如，用户注册成功以后，我们需要执行一些额外的操作，诸如发送邮件通知、送优惠券等。这里我们以用户注册成功后，发送邮件为例，演示事件机制的具体实践。</p>
<p>首先，我们定义一个注册成功的事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import org.springframework.context.ApplicationEvent;</span></span><br><span class="line"><span class="comment">// 将时间发生时的一些关键信息放入到事件中，比如这里注册成功后的用户名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRegisterEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRegisterEvent</span><span class="params">(Object source, String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户注册服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 事件发布者</span></span><br><span class="line">    <span class="comment">// org.springframework.context.ApplicationEventPublisher</span></span><br><span class="line">    <span class="comment">// 本质上调用的是ApplicationEventMulticaster，具体实现是SimpleApplicationEventMulticaster</span></span><br><span class="line">    <span class="comment">// @Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用户注册(将用户信息入库等操作)</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"用户【%s】注册成功"</span>, userName));</span><br><span class="line">        <span class="comment">// 广播事件</span></span><br><span class="line">        publisher.publishEvent(<span class="keyword">new</span> UserRegisterEvent(<span class="keyword">this</span>, userName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送邮件的监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.context.ApplicationListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendRegisterEmailListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">UserRegisterEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(UserRegisterEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                String.format(<span class="string">"给用户【%s】发送注册成功邮件!"</span>, event.getUserName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是使用继承的方式实现事件的发布和监听，也可以使用注解的形式，这里不再赘述。同时，事件监听执行还涉及到同步异步和执行顺序的问题。执行顺序问题，监听器实现接口Ordered或PriorityOrdered，或者在监听器上使用@Order注解。默认是同步执行，如果要开启异步，通过@Async注解监听器即可，或者通过以下方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationEventMulticaster <span class="title">applicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个事件广播器</span></span><br><span class="line">        SimpleApplicationEventMulticaster result = <span class="keyword">new</span> SimpleApplicationEventMulticaster();</span><br><span class="line">        <span class="comment">// 给广播器提供一个线程池，通过这个线程池来调用事件监听器</span></span><br><span class="line">        Executor executor = <span class="keyword">this</span>.applicationEventMulticasterThreadPool().getObject();</span><br><span class="line">        <span class="comment">// 设置异步执行器</span></span><br><span class="line">        result.setTaskExecutor(executor);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolExecutorFactoryBean <span class="title">applicationEventMulticasterThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutorFactoryBean result = <span class="keyword">new</span> ThreadPoolExecutorFactoryBean();</span><br><span class="line">        result.setThreadNamePrefix(<span class="string">"applicationEventMulticasterThreadPool-"</span>);</span><br><span class="line">        result.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为源码中，初始化广播器的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String APPLICATION_EVENT_MULTICASTER_BEAN_NAME = <span class="string">"applicationEventMulticaster"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是事件机制的简单回顾与总结，该部分较为简单，不过多赘述。</p>
<h3 id="5-关于FactoryBean"><a href="#5-关于FactoryBean" class="headerlink" title="5 关于FactoryBean"></a>5 关于<code>FactoryBean</code></h3><p>在面试过程中，一般都会问到BeanFactory和FactoryBean的区别。简单来说，BeanFactory是一个工厂，FactoryBean是一个Bean。</p>
<ul>
<li>BeanFactory<br>  是一个个Factory，也就是IOC容器或对象工厂。在Spring中，<strong>所有的Bean都是由BeanFactory（就是IOC容器）来进行管理的</strong>。</li>
<li>FactoryBean<br>  是一个Bean，<strong>这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean，它的实现与设计模式中的工厂模式和修饰器模式类似。</strong></li>
</ul>
<p>一般情况下，Spring通过反射机制利用<code>&lt;bean&gt;</code>的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在<code>&lt;bean&gt;</code>中提供大量的配置信息，配置方式的灵活性是受限的。为此Spring提供了一个FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。</p>
<p>如果我们配置了一个FactoryBean，那么本质上，Spring容器中存在两个Bean。如下，我们实现一个FactoryBean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">SqlSessionFactory</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 这里初始化可以添加更多的自定义逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlSessionFactory<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Bean标签<code>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;your.path.SqlSessionFactoryBean&quot; /&gt;</code>配置一个FactoryBean，那么在Spring容器中，就存在两个Bean，分别是<code>SqlSessionFactoryBean</code>和<code>getObject()</code>得到的<code>SqlSessionFactory</code>。在Spring容器中对应的beanName分别是<strong><code>&amp;sqlSessionFactory</code></strong>和<strong><code>sqlSessionFactory</code></strong>。</p>
<p>更多的具体实践可以在Spring与MyBatis的集成中学习。</p>
<h3 id="6-Aware（感知）"><a href="#6-Aware（感知）" class="headerlink" title="6 Aware（感知）"></a>6 Aware（感知）</h3><p>Spring容器中的Bean对Spring容器的存在是没有意识的，但是在实际项目中，我们不可避免的要用到 Spring 容器本身提供的资源，这时候要让Bean主动意识到Spring容器的存在，才能调用Spring所提供的资源，这就是Spring Aware。例如，对于一个Bean，如果配置了让其通过Spring管理，那么其自身并不知道自己在Spring容器中的beanName是什么，那Bean可以通过实现接口BeanNameAware，在Spring启动过程中会将beanName告诉正在注册Bean。其他的逻辑也是类似。</p>
<p>找到Spring的Aware接口，按住<code>Ctrl+H</code>可以得到该类的所有子接口及其实现。</p>
<h3 id="7-容器的启动流程"><a href="#7-容器的启动流程" class="headerlink" title="7 容器的启动流程"></a>7 容器的启动流程</h3><blockquote>
<p>以下这个方法所在的类为<code>org.springframework.context.support.AbstractApplicationContext</code>。Spring容器启动就是从这里开始的。具体的解析参见注释。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于org.springframework.context.annotation.AnnotationConfigApplicationContext</span></span><br><span class="line"><span class="comment">// 在调用refresh之前，会注册ConfigurationClassPostProcessor等BeanFactory的后置处理器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// org.springframework.context.support.AbstractApplicationContext</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        <span class="comment">// 官方给出该方法的注释如下：</span></span><br><span class="line">        <span class="comment">//-------------------------------------</span></span><br><span class="line">        <span class="comment">// Prepare this context for refreshing, setting its startup date and</span></span><br><span class="line">        <span class="comment">// active flag as well as performing any initialization of property sources.</span></span><br><span class="line">        <span class="comment">//-------------------------------------</span></span><br><span class="line">        <span class="comment">// 刷新前的准备工作，设置开始时间和启动标志，同时也执行（performing）properties配置文件的初始化</span></span><br><span class="line">        <span class="comment">//-------------------------------------</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="comment">// 这里主要是返回了一个DefaultListableBeanFactory的实例，该实例就是一个BeanFactory</span></span><br><span class="line">        <span class="comment">// 这里其实就是IoC容器的初始化：（为便于理解，我们这里假设是xml形式对bean进行配置）</span></span><br><span class="line">        <span class="comment">// 1、Resource的定位</span></span><br><span class="line">        <span class="comment">//    这里简化为对bean的xml配置文件的找寻；</span></span><br><span class="line">        <span class="comment">// 2、BeanDefinition的载入</span></span><br><span class="line">        <span class="comment">//    这里可以简单理解为将xml中的一个&lt;bean/&gt;标签解析成为一个BeanDefinition；</span></span><br><span class="line">        <span class="comment">// 3、BeanDefinition的注册</span></span><br><span class="line">        <span class="comment">//    这里是将解析出来的所有BeanDefinition写入到Bean工厂的一个map成员变量中。</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        <span class="comment">// 源码注释：</span></span><br><span class="line">        <span class="comment">//-------------------------------------</span></span><br><span class="line">        <span class="comment">// Configure the factory's standard context characteristics,</span></span><br><span class="line">        <span class="comment">// such as the context's ClassLoader and post-processors.</span></span><br><span class="line">        <span class="comment">//-------------------------------------</span></span><br><span class="line">        <span class="comment">// 配置工厂的标准上下文特性，比如上下文的类加载器和工厂后置处理器等</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">// Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line">            <span class="comment">// respecting explicit order if given.</span></span><br><span class="line">            <span class="comment">// Must be called before singleton instantiation.</span></span><br><span class="line">            <span class="comment">//-------------------------------------</span></span><br><span class="line">            <span class="comment">// Bean工厂的后置处理，执行所有配置的BeanFactoryPostProcessor，遵照指定的顺序（如果有）</span></span><br><span class="line">            <span class="comment">// 主要执行PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors</span></span><br><span class="line">            <span class="comment">// 比如org.springframework.context.annotation.ConfigurationClassPostProcessor</span></span><br><span class="line">            <span class="comment">// 对@Configuration的解析</span></span><br><span class="line">            <span class="comment">//-------------------------------------</span></span><br><span class="line">            <span class="comment">// Spring内部自带的对工厂后置处理器的注解解析都是通过类AnnotationConfigUtils来进行的，</span></span><br><span class="line">            <span class="comment">// 重点关注方法registerAnnotationConfigProcessors</span></span><br><span class="line">            <span class="comment">//-------------------------------------</span></span><br><span class="line">            <span class="comment">// 这里强烈禁止通过 BeanFactoryPostProcessor.postProcessBeanFactory() 去提前</span></span><br><span class="line">            <span class="comment">// getBean，因为 BeanPostProcessor 还未准备好，提前获取Bean会导致意想不到的问题</span></span><br><span class="line">            <span class="comment">//-------------------------------------</span></span><br><span class="line">            <span class="comment">// 这里可以重点关注如下的几个类：</span></span><br><span class="line">            <span class="comment">// PropertySourcesPlaceholderConfigurer：对$&#123;value&#125;的解析</span></span><br><span class="line">            <span class="comment">// EventListenerMethodProcessor：对@EventListener的解析</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">// 将配置好的BeanPostProcessor注册到bean工厂</span></span><br><span class="line">            <span class="comment">// 本质上也就是所有的BeanPostProcessor写入到Bean工厂的一个map成员变量中</span></span><br><span class="line">            <span class="comment">// 方法：PostProcessorRegistrationDelegate.registerBeanPostProcessors</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            <span class="comment">// 国际化支持</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            <span class="comment">// 初始化事件广播器，本质上是new SimpleApplicationEventMulticaster()</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            <span class="comment">// 这里应该是预留的，目前没有看到实现</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            <span class="comment">// 注册时间监听器</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            <span class="comment">// 这里主要是调用getBean方法初始化BeanDefinition中所有的Bean，延迟加载的bean除外</span></span><br><span class="line">            <span class="comment">//---------------------------------------------</span></span><br><span class="line">            <span class="comment">// Bean的注册的三个步骤，即getBean调用后：</span></span><br><span class="line">            <span class="comment">// 0.5 InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</span></span><br><span class="line">            <span class="comment">// 1、createBeanInstance</span></span><br><span class="line">            <span class="comment">// 1.5 InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</span></span><br><span class="line">            <span class="comment">// 步骤0.5和1.5是内部使用，不建议外部使用，原文解释如下：</span></span><br><span class="line">            <span class="comment">// This interface is a special purpose interface, mainly for</span></span><br><span class="line">            <span class="comment">// internal use within the framework. </span></span><br><span class="line">            <span class="comment">// It is recommended to implement the plain &#123;@link BeanPostProcessor&#125; </span></span><br><span class="line">            <span class="comment">// interface as far as possible, or to derive from</span></span><br><span class="line">            <span class="comment">// &#123;@link InstantiationAwareBeanPostProcessorAdapter&#125; in order to be shielded</span></span><br><span class="line">            <span class="comment">// from extensions to this interface.</span></span><br><span class="line">            <span class="comment">//---------------------------------------------</span></span><br><span class="line">            <span class="comment">// 2、populateBean</span></span><br><span class="line">            <span class="comment">//---------------------------------------------</span></span><br><span class="line">            <span class="comment">// 2.5 BeanPostProcessor.postProcessBeforeInitialization</span></span><br><span class="line">            <span class="comment">// 3、initializeBean</span></span><br><span class="line">            <span class="comment">// 3.5 BeanPostProcessor.postProcessAfterInitialization</span></span><br><span class="line">            <span class="comment">// 步骤2.5和3.5，实现BeanPostProcessor让Spring容器扫描该Bean即可</span></span><br><span class="line">            <span class="comment">//---------------------------------------------</span></span><br><span class="line">            <span class="comment">// 循环依赖的问题也是在getBean中实现的</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            <span class="comment">// 完成刷新，发布刷新完成的事件，清除刷新过程中的缓存</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                            <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2021-05-27（完）</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring/" rel="tag"># Spring</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/02/threadlocal/" rel="prev" title="ThreadLocal内存泄露问题">
      <i class="fa fa-chevron-left"></i> ThreadLocal内存泄露问题
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-容器初始化"><span class="nav-text">1 容器初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Bean生命周期"><span class="nav-text">2 Bean生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-createBeanInstance"><span class="nav-text">2.1 createBeanInstance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-populateBean"><span class="nav-text">2.2 populateBean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-initializeBean"><span class="nav-text">2.3 initializeBean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-destroy"><span class="nav-text">2.4 destroy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Bean的循环依赖"><span class="nav-text">3 Bean的循环依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-循环注入流程"><span class="nav-text">3.1 循环注入流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-为什么要三级缓存"><span class="nav-text">3.2 为什么要三级缓存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-事件机制"><span class="nav-text">4 事件机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-关于FactoryBean"><span class="nav-text">5 关于FactoryBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Aware（感知）"><span class="nav-text">6 Aware（感知）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-容器的启动流程"><span class="nav-text">7 容器的启动流程</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="勤恳的小码农"
      src="/images/profile-photo.jpg">
  <p class="site-author-name" itemprop="name">勤恳的小码农</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/vectooor" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vectooor" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">勤恳的小码农</span>
</div>

        








        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: '9a9v7zu2yyqTWSjtdBY5WHS4-gzGzoHsz',
    appKey: 'rka4jpeukne9S0n6xra3OYua',
    placeholder: "Just go go",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: true,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
